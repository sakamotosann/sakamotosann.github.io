<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[BISTU OJ]]></title>
    <url>%2Fpost%2Fbdf67b35.html</url>
    <content type="text"><![CDATA[BISTU OJ 1001 整数求和12345678#include &lt;stdio.h&gt; int main()&#123; int a, b; scanf("%d %d", &amp;a, &amp;b); printf("%d\n", a + b); return 0;&#125; 1002 取石子游戏(Wythoff博弈)1234567891011121314#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;math.h&gt;using namespace std;int a, b;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); while (cin &gt;&gt; a &gt;&gt; b) &#123; int res = (int)(abs(a - b)*(1 + sqrt(5)) / 2) == min(a, b) ? 0 : 1; cout &lt;&lt; res &lt;&lt; endl; &#125;&#125; 1003 Apple tree1234567891011121314#include &lt;iostream&gt;using namespace std;int a[10], b, sum = 0;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); for (int i = 1; i &lt;= 10; ++i) cin &gt;&gt; a[i]; cin &gt;&gt; b; for (int i = 1; i &lt;= 10; ++i) if (a[i] &lt;= b + 30) sum++; cout &lt;&lt; sum &lt;&lt; endl;&#125; 1004 sum of integers12345678910111213141516#include &lt;iostream&gt;using namespace std;int t, n;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; t; while (t--) &#123; int sum = 0; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) sum += i; cout &lt;&lt; sum &lt;&lt; endl &lt;&lt; endl; &#125;&#125; 1005 两个数比较1234567891011121314#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int t, a, b;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; t; while (t--) &#123; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; max(a, b) &lt;&lt; endl; &#125;&#125; 1006 Count the Numbers1234567891011121314151617#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;int t, n;map&lt;int, int&gt; ans;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; t; ans[t]++; &#125; for (map&lt;int, int&gt;::iterator it = ans.begin(); it != ans.end(); ++it) cout &lt;&lt; (*it).first &lt;&lt; ' ' &lt;&lt; (*it).second &lt;&lt; endl;&#125; 1007 Saving Plan123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;math.h&gt;using namespace std;int t, b = 0, cnt = 0;bool flag = true;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); for (int i = 1; i &lt;= 12; ++i) &#123; cin &gt;&gt; t; b += 300 - t; if (b &gt;= 100) &#123; cnt += (int)floor((double)b / 100); b %= 100; &#125; if (b &lt; 0) &#123; cout &lt;&lt; -i &lt;&lt; endl; flag = false; break; &#125; &#125; if (flag) cout &lt;&lt; cnt * 120 &lt;&lt; endl;&#125; 1008 Prime Generator1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;math.h&gt;using namespace std;int isPrime(int x)&#123; if (x == 1) return 0; if (x == 2 || x == 3) return 1; if (x % 6 != 1 &amp;&amp; x % 6 != 5) return 0; int t = (int)sqrt(x); for (int i = 5; i &lt;= t; i += 6) if (x%i == 0 || x % (i + 2) == 0) return 0; return 1;&#125;int t;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; t; while (t--) &#123; int l, r; cin &gt;&gt; l &gt;&gt; r; for (int i = l; i &lt;= r; ++i) if (isPrime(i)) cout &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; &#125;&#125; 1009 简单的四则运算12345678910111213#include &lt;iostream&gt;using namespace std;int n, x, y;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; n; while (n--) &#123; cin &gt;&gt; x &gt;&gt; y; cout &lt;&lt; x + y &lt;&lt; ' ' &lt;&lt; x*y &lt;&lt; ' ' &lt;&lt; x - y &lt;&lt; ' ' &lt;&lt; x / y &lt;&lt; endl; &#125;&#125; 1010 找出两个数的最大值1234567891011121314151617#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n, x, y;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; n; while (n--) &#123; cin &gt;&gt; x &gt;&gt; y; if (x == y) cout &lt;&lt; "These numbers are equal." &lt;&lt; endl; else cout &lt;&lt; max(x, y) &lt;&lt; endl; &#125;&#125; 1011 三个数的一些基本运算1234567891011121314#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n, x, y, z;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; n; while (n--) &#123; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; cout &lt;&lt; x + y + z &lt;&lt; ' ' &lt;&lt; (x + y + z) / 3 &lt;&lt; ' ' &lt;&lt; x*y*z &lt;&lt; ' ' &lt;&lt; min(min(x, y), min(y, z)) &lt;&lt; ' ' &lt;&lt; max(max(x, y), max(y, z)) &lt;&lt; endl; &#125;&#125; 1012 圆的直径、周长和面积123456789101112#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;math.h&gt;using namespace std;const double PI = acos(-1);double r;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cout.setf(ios::fixed); cin &gt;&gt; r; cout &lt;&lt; setprecision(2) &lt;&lt; 2 * r &lt;&lt; ' ' &lt;&lt; 2 * PI*r &lt;&lt; ' ' &lt;&lt; PI*r*r &lt;&lt; endl;&#125; 1013 找出5个数的极值12345678910111213141516#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n, a[6];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; n; while (n--) &#123; for (int i = 1; i &lt;= 5; ++i) cin &gt;&gt; a[i]; sort(a + 1, a + 6); cout &lt;&lt; a[5] &lt;&lt; ' ' &lt;&lt; a[1] &lt;&lt; endl; &#125;&#125; 1014 数的奇偶性12345678910111213#include &lt;iostream&gt;using namespace std;int n, x;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; n; while (n--) &#123; cin &gt;&gt; x; x = x &amp; 1 ? 1 : 0; cout &lt;&lt; x &lt;&lt; endl; &#125; 1015 数字分离12345678910111213141516#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;string s;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); while (cin &gt;&gt; s&amp;&amp;s != "0") for (int i = 0; i &lt; (signed)s.size(); ++i) &#123; if (i &lt; (signed)s.size() - 1) cout &lt;&lt; s[i] &lt;&lt; ' '; else cout &lt;&lt; s[i] &lt;&lt; endl; &#125;&#125; 1016 数字回文12345678910111213141516171819#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;string s;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); while (cin &gt;&gt; s&amp;&amp;s != "0") &#123; bool flag = true; for (int i = 0; i &lt; (signed)s.size() / 2; ++i) if (s[i] != s[s.size() - i - 1]) flag = false; if (flag) cout &lt;&lt; "YES." &lt;&lt; endl; else cout &lt;&lt; "NO." &lt;&lt; endl; &#125;&#125; 1017 二进制转换为十进制12345678910111213141516#include &lt;iostream&gt;#include &lt;bitset&gt;using namespace std;int n;string s;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; n; while (n--) &#123; cin &gt;&gt; s; bitset&lt;32&gt; b(s); cout &lt;&lt; b.to_ulong() &lt;&lt; endl; &#125;&#125; 1018 谁是最大数123456789101112131415161718#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = (int)1e3 + 5;int t, m, a[MAXN];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; t; while (t--) &#123; cin &gt;&gt; m; for (int i = 1; i &lt;= m; ++i) cin &gt;&gt; a[i]; sort(a + 1, a + m + 1); cout &lt;&lt; a[m] &lt;&lt; endl; &#125;&#125; 1019 构成三角形的条件1234567891011121314151617#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int t, a[4];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; t; while (t--) &#123; for (int i = 1; i &lt;= 3; ++i) cin &gt;&gt; a[i]; sort(a + 1, a + 4); a[0] = a[1] + a[2] &gt; a[3] ? 1 : 0; cout &lt;&lt; a[0] &lt;&lt; endl; &#125;&#125; 1020 构成直角三角形的条件1234567891011121314151617#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int t, a[4];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; t; while (t--) &#123; for (int i = 1; i &lt;= 3; ++i) cin &gt;&gt; a[i]; sort(a + 1, a + 4); a[0] = a[1] * a[1] + a[2] * a[2] == a[3] * a[3] ? 1 : 0; cout &lt;&lt; a[0] &lt;&lt; endl; &#125;&#125; 1021 圣诞节礼物1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = (int)1e5 + 5;int n, m, t, a[MAXN];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); while (cin &gt;&gt; n &gt;&gt; m &amp;&amp; n + m) &#123; int cnt = 0; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i]; sort(a + 1, a + 1 + n); for (int i = 1; i &lt;= m; ++i) &#123; cin &gt;&gt; t; if (binary_search(a + 1, a + 1 + n, t)) cnt++; &#125; if (cnt == m) cout &lt;&lt; "YES" &lt;&lt; endl; else cout &lt;&lt; "NO" &lt;&lt; endl; &#125;&#125; 1022 超级病毒123456789101112131415161718#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int t;string s1, s2;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; t; while (t--) &#123; int cnt = 0, pos = 0; cin &gt;&gt; s1 &gt;&gt; s2; while ((pos = s2.find(s1, pos)) != string::npos) pos++, cnt++; cout &lt;&lt; cnt &lt;&lt; endl; &#125;&#125; 1023 短信套餐123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = (int)1e3 + 5;int n, m, f[MAXN];double a, p[MAXN], res[MAXN];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cout.setf(ios::fixed); while (cin &gt;&gt; n &gt;&gt; m &amp;&amp; n + m) &#123; cin &gt;&gt; a; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; p[i] &gt;&gt; f[i]; res[i] = p[i]; if (f[i] &lt; m) res[i] += (m - f[i])*a; &#125; sort(res + 1, res + 1 + n); cout &lt;&lt; setprecision(2) &lt;&lt; res[1] &lt;&lt; endl; &#125;&#125; 1024 HELLOWORLD1234567#include &lt;iostream&gt;using namespace std;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cout &lt;&lt; "Hello, World!你好！" &lt;&lt; endl;&#125; 1025 算术运算1234567891011121314#include &lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;int a, b;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cout.setf(ios::fixed); cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; a &lt;&lt; '+' &lt;&lt; b &lt;&lt; '=' &lt;&lt; a + b &lt;&lt; endl; cout &lt;&lt; a &lt;&lt; '-' &lt;&lt; b &lt;&lt; '=' &lt;&lt; a - b &lt;&lt; endl; cout &lt;&lt; a &lt;&lt; '*' &lt;&lt; b &lt;&lt; '=' &lt;&lt; a * b &lt;&lt; endl; cout &lt;&lt; setprecision(2) &lt;&lt; a &lt;&lt; '/' &lt;&lt; b &lt;&lt; '=' &lt;&lt; (double)a / b &lt;&lt; endl; cout &lt;&lt; a &lt;&lt; '%' &lt;&lt; b &lt;&lt; '=' &lt;&lt; a % b &lt;&lt; endl;&#125; 1026 字母大小写转换123456789#include &lt;iostream&gt;using namespace std;char c;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; c; cout &lt;&lt; char(c + 32) &lt;&lt; endl;&#125; 1027 产品利润计算12345678910#include &lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;double a, b, c, d;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cout.setf(ios::fixed); cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d; cout &lt;&lt; setprecision(2) &lt;&lt; a*b - c - a*d &lt;&lt; endl;&#125; 1028 人口计算1234567891011#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;math.h&gt;using namespace std;double a, b, c;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cout.setf(ios::fixed); cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; cout &lt;&lt; setprecision(2) &lt;&lt; a*pow(1 + b, c) &lt;&lt; endl;&#125; 1029 三个数求最大值12345678910#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int a, b, c;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; cout &lt;&lt; "max=" &lt;&lt; max(max(a, b), max(b, c)) &lt;&lt; endl;&#125; 1030 生产成本123456789101112#include &lt;iostream&gt;using namespace std;int a;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; a; if (a &lt; 10000) cout &lt;&lt; a &lt;&lt; ' ' &lt;&lt; 20000 + 10 * a &lt;&lt; ' ' &lt;&lt; 10 &lt;&lt; endl; else cout &lt;&lt; a &lt;&lt; ' ' &lt;&lt; 40000 + 5 * a &lt;&lt; ' ' &lt;&lt; 5 &lt;&lt; endl;&#125; 1031 分段函数123456789101112131415#include &lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;double x;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cout.setf(ios::fixed); cin &gt;&gt; x; if (x &lt; 1) cout &lt;&lt; setprecision(2) &lt;&lt; "x=" &lt;&lt; x &lt;&lt; ",y=" &lt;&lt; x &lt;&lt; endl; else if (1 &lt;= x&amp;&amp;x &lt; 10) cout &lt;&lt; setprecision(2) &lt;&lt; "x=" &lt;&lt; x &lt;&lt; ",y=" &lt;&lt; 2 * x - 1 &lt;&lt; endl; else cout &lt;&lt; setprecision(2) &lt;&lt; "x=" &lt;&lt; x &lt;&lt; ",y=" &lt;&lt; 3 * x - 11 &lt;&lt; endl;&#125; 1032 字符分类12345678910111213141516#include &lt;iostream&gt;using namespace std;char c;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; c; if ('A' &lt;= c&amp;&amp;c &lt;= 'Z') cout &lt;&lt; 1 &lt;&lt; endl; else if ('a' &lt;= c&amp;&amp;c &lt;= 'z') cout &lt;&lt; 2 &lt;&lt; endl; else if ('1' &lt;= c&amp;&amp;c &lt;= '9') cout &lt;&lt; 3 &lt;&lt; endl; else cout &lt;&lt; 4 &lt;&lt; endl;&#125; 1033 简易计算器12345678910111213141516171819202122232425#include &lt;stdio.h&gt;double a, b;char c;int main()&#123; scanf("%lf%c%lf", &amp;a, &amp;c, &amp;b); switch (c) &#123; case '+': printf("%.2lf+%.2lf=%.2lf\n", a, b, a + b); break; case '-': printf("%.2lf-%.2lf=%.2lf\n", a, b, a - b); break; case '*': printf("%.2lf*%.2lf=%.2lf\n", a, b, a * b); break; case '/': if (b) printf("%.2lf/%.2lf=%.2lf\n", a, b, a / b); else printf("除数为0\n"); break; &#125;&#125; 1034 找中间数123456789101112#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int a[4];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; a[1] &gt;&gt; a[2] &gt;&gt; a[3]; sort(a + 1, a + 4); cout &lt;&lt; a[2] &lt;&lt; endl;&#125;` 1035 数的平方表12345678910#include &lt;iostream&gt;using namespace std;int l, r;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; l &gt;&gt; r; for (int i = l; i &lt;= r; ++i) cout &lt;&lt; i &lt;&lt; "的平方是" &lt;&lt; i*i &lt;&lt; endl;&#125; 1036 平方和1234567891011#include &lt;iostream&gt;using namespace std;int n, sum = 0;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) sum += i*i; cout &lt;&lt; sum &lt;&lt; endl;&#125; 1037 被7整除的数123456789101112#include &lt;iostream&gt;using namespace std;int l, r;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; l &gt;&gt; r; for (int i = l; i &lt;= r; ++i) if (i % 7 == 0) cout &lt;&lt; i &lt;&lt; ' '; cout &lt;&lt; endl;&#125; 1038 求和值123456789101112#include &lt;iostream&gt;using namespace std;int n, a, sum, t;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; n &gt;&gt; a; t = sum = a; for (int i = 1; i &lt;= n - 1; ++i) sum += (a = a * 10 + t); cout &lt;&lt; "s=" &lt;&lt; sum &lt;&lt; endl;&#125; 1039 水仙花数1234567891011121314#include &lt;iostream&gt;using namespace std;int l, r;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; l &gt;&gt; r; for (int i = l; i &lt;= r; ++i) &#123; int a = i / 100, b = i / 10 % 10, c = i % 10; if (i == a*a*a + b*b*b + c*c*c) cout &lt;&lt; i &lt;&lt; endl; &#125;&#125; 1040 奇数的乘积123456789101112131415161718#include &lt;iostream&gt;using namespace std;int n, t;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); while (cin &gt;&gt; n) &#123; int ans = 1; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; t; if (t &amp; 1) ans *= t; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125; 1041 素数12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;math.h&gt;using namespace std;int isPrime(int x)&#123; if (x == 1) return 0; if (x == 2 || x == 3) return 1; if (x % 6 != 1 &amp;&amp; x % 6 != 5) return 0; int t = (int)sqrt(x); for (int i = 5; i &lt;= t; i += 6) if (x%i == 0 || x % (i + 2) == 0) return 0; return 1;&#125;int t, a;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; t; while (t--) &#123; cin &gt;&gt; a; cout &lt;&lt; isPrime(a) &lt;&lt; endl; &#125;&#125; 1042 津津的学习情绪1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;int t, a, b;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; t; while (t--) &#123; int ans = 0, mx = 0; for (int i = 1; i &lt;= 7; ++i) &#123; cin &gt;&gt; a &gt;&gt; b; if (a + b &gt; 8) if (mx &lt; a + b) &#123; mx = a + b; ans = i; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125; 1043 打印菱形123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;int n;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = n - i; j &gt;= 1; --j) cout &lt;&lt; ' '; for (int j = 1; j &lt; i * 2; ++j) cout &lt;&lt; '*'; cout &lt;&lt; endl; &#125; for (int i = 1; i &lt; n; ++i) &#123; for (int j = 1; j &lt;= i; ++j) cout &lt;&lt; ' '; for (int j = (n - i) * 2 - 1; j &gt;= 1; --j) cout &lt;&lt; '*'; cout &lt;&lt; endl; &#125;&#125; 1044 字符串处理12345678910111213#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;string s;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; s; for (string::iterator it = s.begin(); it != s.end(); ++it) if ('a' &lt;= *it&amp;&amp;*it &lt;= 'z'||'A' &lt;= *it&amp;&amp;*it &lt;= 'Z') cout &lt;&lt; *it; cout &lt;&lt; endl;&#125; 1045 最值问题12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n, a[11], mi = INT_MAX, imi = -1, mx = INT_MIN, imx = -1;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; a[i]; if (mi &gt; a[i]) &#123; mi = a[i]; imi = i; &#125; if (mx &lt; a[i]) &#123; mx = a[i]; imx = i; &#125; &#125; swap(a[1], a[imi]); swap(a[n], a[imx]); for (int i = 1; i &lt;= n; ++i) cout &lt;&lt; a[i] &lt;&lt; ' '; cout &lt;&lt; endl;&#125; 1046 爬井的小明12345678910#include &lt;iostream&gt;#include &lt;math.h&gt;using namespace std;int h, u, d;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; h &gt;&gt; u &gt;&gt; d; cout &lt;&lt; ceil((double)(h - u) / (u - d)) * 2 + 1 &lt;&lt; endl;&#125; 1047 插入排序123456789101112131415161718#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n, m, a[105];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); while (cin &gt;&gt; n &gt;&gt; m&amp;&amp;n + m) &#123; for (int i = 0; i &lt; n; ++i) cin &gt;&gt; a[i]; a[n] = m; sort(a, a + n + 1); for (int i = 0; i &lt;= n; ++i) cout &lt;&lt; a[i] &lt;&lt; ' '; cout &lt;&lt; endl; &#125;&#125; 1048 统计不及格人数12345678910111213141516#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n, t, ans = 0;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; t; if (t &lt; 60) ans++; &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125; 1049 数组逆序123456789101112131415161718#include &lt;iostream&gt;using namespace std;int n, m, a[105], cnt = 1;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i]; cin &gt;&gt; m; for (int i = n - m + 1; cnt &lt;= n; ++i, cnt++) &#123; if (i &gt; n) i -= n; cout &lt;&lt; a[i] &lt;&lt; ' '; &#125; cout &lt;&lt; endl;&#125; 1050 大小写转换12345678910111213141516171819#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;string s;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; s; for (string::iterator it = s.begin(); it != s.end(); ++it) &#123; if ('a' &lt;= *it&amp;&amp;*it &lt;= 'z') cout &lt;&lt; char(*it - 32); else if ('A' &lt;= *it&amp;&amp;*it &lt;= 'Z') cout &lt;&lt; char(*it + 32); else cout &lt;&lt; *it; &#125; cout &lt;&lt; endl;&#125; 1051 单词统计12345678910111213141516#include &lt;stdio.h&gt;const int MAXN = (int)1e7 + 5;char s[MAXN];int ans = 0, flag = 0;int main()&#123; scanf("%[^\n]", s); for (int i = 0; s[i] != '\0'; ++i) &#123; if (s[i] != ' ' &amp;&amp; !flag) flag = 1, ans++; if (s[i] == ' ' &amp;&amp; flag) flag = 0; &#125; printf("%d\n", ans);&#125; 1052 排序12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int t;vector&lt;pair&lt;int, int&gt; &gt; a;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); for (int i = 1; i &lt;= 10; ++i) &#123; cin &gt;&gt; t; a.push_back(make_pair(t, i)); &#125; sort(a.begin(), a.end()); for (vector&lt;pair&lt;int, int&gt; &gt;::iterator it = a.begin(); it != a.end(); ++it) cout &lt;&lt; (*it).first &lt;&lt; ' '; cout &lt;&lt; endl; for (vector&lt;pair&lt;int, int&gt; &gt;::iterator it = a.begin(); it != a.end(); ++it) cout &lt;&lt; (*it).second &lt;&lt; ' '; cout &lt;&lt; endl;&#125; 1053 两数组最短距离123456789101112131415161718192021//O(n+m)的操作类似于merge sort的merge操作，搞两个指针同时扫就可以了//然而还是WA了，看了讨论才知道数据出错了，没有排序QAQ#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = (int)1e3 + 5;int m, n, f[MAXN], g[MAXN], mi = INT_MAX;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; m &gt;&gt; n; for (int i = 1; i &lt;= m; ++i) cin &gt;&gt; f[i]; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; g[i]; sort(f + 1, f + 1 + m); sort(g + 1, g + 1 + n); for (int i = 1, j = 1; i &lt;= m&amp;&amp;j &lt;= n; f[i] &lt; g[j] ? i++ : j++) mi = min(mi, abs(f[i] - g[j])); cout &lt;&lt; mi &lt;&lt; endl;&#125; 1054 平方根计算1234567891011121314#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;math.h&gt;using namespace std;double x;int n;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cout.setf(ios::fixed); cin &gt;&gt; x &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) x = sqrt(i + x); cout &lt;&lt; setprecision(2) &lt;&lt; x &lt;&lt; endl;&#125; 1055 数据统计123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;int n, a[41];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); memset(a, 0, sizeof(a)); for (int i = 1; i &lt;= 40; ++i) &#123; cin &gt;&gt; n; a[n]++; &#125; cout &lt;&lt; "产品 得票 直方图" &lt;&lt; endl; for (int i = 1; i &lt;= 10; ++i) &#123; cout &lt;&lt; i &lt;&lt; " " &lt;&lt; a[i] &lt;&lt; " "; for (int j = 1; j &lt;= a[i]; ++j) cout &lt;&lt; '*'; cout &lt;&lt; endl; &#125;&#125; 1056 字母大小写转换改进1234567891011121314#include &lt;iostream&gt;using namespace std;char c;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; c; if ('a' &lt;= c&amp;&amp;c &lt;= 'z') cout &lt;&lt; char(c - 32) &lt;&lt; endl; else if ('A' &lt;= c&amp;&amp;c &lt;= 'Z') cout &lt;&lt; char(c + 32) &lt;&lt; endl; else cout &lt;&lt; "非字母：" &lt;&lt; c &lt;&lt; endl;&#125; 1057 圆柱体的体积和侧面积123456789101112#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;math.h&gt;using namespace std;const double PI = acos(-1);double r, h;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cout.setf(ios::fixed); cin &gt;&gt; r &gt;&gt; h; cout &lt;&lt; setprecision(3) &lt;&lt; PI*r*r*h &lt;&lt; ' ' &lt;&lt; 2 * PI*r *h &lt;&lt; endl;&#125; 1058 分段函数21234567891011121314151617#include &lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;double x;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cout.setf(ios::fixed); cin &gt;&gt; x; if (x &lt; 3) cout &lt;&lt; setprecision(3) &lt;&lt; "x=" &lt;&lt; x &lt;&lt; ",y=" &lt;&lt; x + 5 &lt;&lt; endl; else if (x == 3) cout &lt;&lt; setprecision(3) &lt;&lt; "x=" &lt;&lt; x &lt;&lt; ",y=" &lt;&lt; 2 * x &lt;&lt; endl; else if (3 &lt; x&amp;&amp;x &lt; 10) cout &lt;&lt; setprecision(3) &lt;&lt; "x=" &lt;&lt; x &lt;&lt; ",y=" &lt;&lt; 6 * x - 4 &lt;&lt; endl; else cout &lt;&lt; setprecision(3) &lt;&lt; "x=" &lt;&lt; x &lt;&lt; ",y=" &lt;&lt; 3 * x - 11 &lt;&lt; endl;&#125; 1059 数的简单处理123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;algorithm&gt;using namespace std;double a[4];int cnt = 1, pos = -1;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cout.setf(ios::fixed); for (int i = 1; i &lt;= 3; ++i) cin &gt;&gt; a[i]; sort(a + 1, a + 4); for (int i = 1; i &lt; 3; ++i) if (a[i] == a[i + 1]) pos = i - 1, cnt++; if (cnt == 3) cout &lt;&lt; setprecision(2) &lt;&lt; "一样，都是：" &lt;&lt; a[1] &lt;&lt; endl; else if (cnt == 2) &#123; if (pos) cout &lt;&lt; setprecision(2) &lt;&lt; a[3] &lt;&lt; "(2) " &lt;&lt; a[1] &lt;&lt; endl; else cout &lt;&lt; setprecision(2) &lt;&lt; a[1] &lt;&lt; "(2) " &lt;&lt; a[3] &lt;&lt; endl; &#125; else cout &lt;&lt; setprecision(2) &lt;&lt; a[2] &lt;&lt; endl;&#125; 1060 阶乘和123456789101112131415#include &lt;iostream&gt;using namespace std;int n, a[11];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); a[0] = 1; for (int i = 1; i &lt;= 10; ++i) a[i] = a[i - 1] * i; for (int i = 2; i &lt;= 10; ++i) a[i] += a[i - 1]; a[0] = 0; cin &gt;&gt; n; cout &lt;&lt; "sum=" &lt;&lt; a[n] &lt;&lt; endl;&#125; 1061 找出三个数的最小值1234567891011121314151617#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n, a, b, c;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; n; while (n--) &#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; if (a == b&amp;&amp;b == c) cout &lt;&lt; "These numbers are equal." &lt;&lt; endl; else cout &lt;&lt; min(min(a, b), min(b, c)) &lt;&lt; endl; &#125;&#125; 1062 鞍点问题1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 11;int n, m, a[MAXN][MAXN], mxi[MAXN];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); while (cin &gt;&gt; m &gt;&gt; n) &#123; bool flag = true; memset(mxi, 0, sizeof(mxi)); for (int i = 1; i &lt;= m; ++i) for (int j = 1; j &lt;= n; ++j) &#123; cin &gt;&gt; a[i][j]; if (a[i][mxi[i]] &lt; a[i][j]) mxi[i] = j; &#125; for (int i = 1; i &lt;= m; ++i) &#123; int mi = a[i][mxi[i]]; for (int j = 1; j &lt;= m; ++j) mi = min(mi, a[j][mxi[i]]); if (mi == a[i][mxi[i]]) &#123; cout &lt;&lt; "Array[" &lt;&lt; i - 1 &lt;&lt; "][" &lt;&lt; mxi[i] - 1 &lt;&lt; "]=" &lt;&lt; a[i][mxi[i]] &lt;&lt; endl; flag = false; break; &#125; &#125; if (flag) cout &lt;&lt; "None" &lt;&lt; endl; &#125;&#125; 1063 方阵对角线元素和1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;const int MAXN = 11;int n, a[MAXN][MAXN], sum1 = 0, sum2 = 0;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) &#123; cin &gt;&gt; a[i][j]; if (i == j) sum1 += a[i][j]; if (i + j == n + 1) sum2 += a[i][j]; &#125; cout &lt;&lt; "主对角线=" &lt;&lt; sum1 &lt;&lt; endl; cout &lt;&lt; "副对角线=" &lt;&lt; sum2 &lt;&lt; endl;&#125; 1064 杨辉三角形1234567891011121314151617#include &lt;iostream&gt;using namespace std;const int MAXN = 11;int n, a[MAXN][MAXN];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); memset(a, 0, sizeof(a)); cin &gt;&gt; n; cout &lt;&lt; (a[1][1] = 1) &lt;&lt; ' ' &lt;&lt; endl; for (int i = 2; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= i; ++j) cout &lt;&lt; (a[i][j] = a[i - 1][j - 1] + a[i - 1][j]) &lt;&lt; ' '; cout &lt;&lt; endl; &#125;&#125; 1065 同成绩人数统计123456789101112131415161718#include &lt;iostream&gt;using namespace std;int n, t, r, a[101];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); while (cin &gt;&gt; n&amp;&amp;n) &#123; memset(a, 0, sizeof(a)); for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; t; a[t]++; &#125; cin &gt;&gt; r; cout &lt;&lt; a[r] &lt;&lt; endl; &#125;&#125; 1067 统计子串个数123456789101112#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;string str, s;int idx = 0, cnt = 0;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; str &gt;&gt; s; for (; ~(idx = str.find(s, idx))++; ++cnt); cout &lt;&lt; cnt &lt;&lt; endl;&#125; 1068 素数对1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;math.h&gt;using namespace std;int isPrime(int x)&#123; if (x == 1) return 0; if (x == 2 || x == 3) return 1; if (x % 6 != 1 &amp;&amp; x % 6 != 5) return 0; int t = (int)sqrt(x); for (int i = 5; i &lt;= t; i += 6) if (x%i == 0 || x % (i + 2) == 0) return 0; return 1;&#125;int m;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); while (cin &gt;&gt; m) for (int i = m / 2 - 1; i &gt;= 2; --i) if (isPrime(i) &amp;&amp; isPrime(m - i)) &#123; cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; m - i &lt;&lt; endl; break; &#125;&#125; 1069 函数表达式计算123456789101112131415//这题和1054一样...#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;math.h&gt;using namespace std;double x;int n;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cout.setf(ios::fixed); cin &gt;&gt; x &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) x = sqrt(i + x); cout &lt;&lt; setprecision(2) &lt;&lt; x &lt;&lt; endl;&#125; 1070 十进制转换其它进制123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;int n, r, a[50], len;char c;void convert(int n, int r)&#123; n = n &lt; 0 ? -n : n; while (n) a[++len] = n%r, n /= r;&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); while (cin &gt;&gt; n &gt;&gt; r) &#123; len = 0; convert(n, r); if (n &lt; 0) cout &lt;&lt; '-'; for (int i = len; i &gt; 0; --i) cout &lt;&lt; char(a[i] &gt; 9 ? a[i] - 10 + 'A' : a[i] + '0'); cout &lt;&lt; endl; &#125;&#125; 1071 排队问题1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;const int MAXN = (int)1e4 + 5;int T, M, a[MAXN], N;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; M; for (int i = 1; i &lt;= M; ++i) cin &gt;&gt; a[i]; cin &gt;&gt; N; for (int i = 1; i &lt;= M; ++i) if (a[i] != N) cout &lt;&lt; a[i] &lt;&lt; ' '; cout &lt;&lt; endl; &#125;&#125; 1072 练习赛题1123456789#include &lt;iostream&gt;using namespace std;int a, b;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; a - b &lt;&lt; endl;&#125; 1073 练习赛题212345678910111213#include &lt;iostream&gt;using namespace std;int n, a, b;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; n; while (n--) &#123; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; a - b &lt;&lt; endl; &#125;&#125; 1074 练习赛题3123456789#include &lt;iostream&gt;using namespace std;int a, b;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); while (cin &gt;&gt; a &gt;&gt; b&amp;&amp;a + b) cout &lt;&lt; a - b &lt;&lt; endl;&#125; 1075 练习赛题4123456789#include &lt;iostream&gt;using namespace std;int a, b;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); while (cin &gt;&gt; a &gt;&gt; b) cout &lt;&lt; a - b &lt;&lt; endl;&#125; 1076 超级难题啊1234567891011121314151617#include &lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;typedef long long ll;int N, M, t;ll sum = 0;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cout.setf(ios::fixed); cin &gt;&gt; N &gt;&gt; M; for (int i = 1; i &lt;= M; ++i) &#123; cin &gt;&gt; t; sum += t; &#125; cout &lt;&lt; setprecision(1) &lt;&lt; sum / (double)M &lt;&lt; endl;&#125; 1077 日期时间问题123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;int T, year, month, day, h, m, s;int main()&#123; scanf("%d", &amp;T); while (T--) &#123; bool flag = false; scanf("%d/%d/%d-%d:%d:%d", &amp;year, &amp;month, &amp;day, &amp;h, &amp;m, &amp;s); if (h &gt;= 12) h -= 12, flag = true; if (!h) h += 12; printf("%02d/%02d/%04d-%02d:%02d:%02d", month, day, year, h, m, s); if (flag) printf("pm\n"); else printf("am\n"); &#125;&#125; 1078 灌水1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;math.h&gt;using namespace std;const int MAXN = (int)1e4 + 5;int T, N, dp[MAXN];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); for (int i = 1; i &lt; MAXN; ++i) &#123; dp[i] = dp[i - 1] + 1; for (int j = 2; j &lt;= i / 2; ++j) if (dp[i] &gt; dp[j] + 5 + ((int)ceil(i / (double)j) - 1) * 2) dp[i] = dp[j] + 5 + ((int)ceil(i / (double)j) - 1) * 2; &#125; cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; N; cout &lt;&lt; dp[N] &lt;&lt; endl; &#125;&#125; 1079 函数实验二（1）12345678910111213141516#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int N, a[6];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; N; while (N--) &#123; for (int i = 1; i &lt;= 5; ++i) cin &gt;&gt; a[i]; sort(a + 1, a + 6); cout &lt;&lt; a[5] &lt;&lt; endl; &#125;&#125; 1080 C函数实验二(2)12345678910111213141516#include &lt;iostream&gt;using namespace std;int m, n;int f(int x)&#123; int r = 1; for (int i = 1; i &lt;= x; ++i) r *= i; return r;&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); while (cin &gt;&gt; m &gt;&gt; n&amp;&amp;m + n) cout &lt;&lt; f(m) / f(m - n) &lt;&lt; endl;&#125; 1081 C函数实验二（3）12345678910111213141516#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;iomanip&gt;using namespace std;int a[11], sum = 0;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cout.setf(ios::fixed); for (int i = 1; i &lt;= 10; ++i) &#123; cin &gt;&gt; a[i]; sum += a[i]; &#125; cout &lt;&lt; sum &lt;&lt; endl; cout &lt;&lt; setprecision(2) &lt;&lt; sum / 10. &lt;&lt; endl;&#125; 1082 递归公约数12345678910111213141516#include &lt;iostream&gt;using namespace std;int n, m;int gcd(int x, int y)&#123; if (!x || !y) return x &gt; y ? x : y; for (int t; t = x % y, t; x = y, y = t); return y;&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); while (cin &gt;&gt; n &gt;&gt; m) cout &lt;&lt; gcd(n, m) &lt;&lt; endl;&#125; 1083 三位数数字排序1234567891011121314#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;using namespace std;string s;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); while (cin &gt;&gt; s&amp;&amp;s != "0") &#123; sort(s.begin(), s.end()); cout &lt;&lt; s &lt;&lt; endl; &#125;&#125; 1084 合法的C标识符12345678910111213141516171819202122#include &lt;stdio.h&gt;int n;char s[10];int main()&#123; scanf("%d", &amp;n); while (n--) &#123; getchar(); scanf("%[^\n]", s); int flag = 1; if (s[0] &lt; 'A' || s[0] &gt; 'Z'&amp;&amp;s[0] &lt; '_' || s[0] == '`' || s[0]&gt;'z') flag = 0; for (int i = 1; s[i] != '\0' &amp;&amp; flag; ++i) if (s[i] &lt; '0' || s[i] &gt; '9'&amp;&amp;s[i] &lt; 'A' || s[i] &gt; 'Z'&amp;&amp;s[i] &lt; '_' || s[i] == '`' || s[0]&gt;'z') flag = 0; if (flag) printf("合法！\n"); else printf("不合法！\n"); &#125;&#125; 1085 时间间隔123456789101112131415#include &lt;stdio.h&gt;int sh, sm, ss, eh, em, es, n, flag = 1, ans;int main()&#123; scanf("%d:%d:%d%d:%d:%d%d", &amp;sh, &amp;sm, &amp;ss, &amp;eh, &amp;em, &amp;es, &amp;n); if (sh &lt; 0 || sh&gt;23 || eh &lt; 0 || eh&gt;23 || sm &lt; 0 || sm&gt;59 || em &lt; 0 || em&gt;59 || ss &lt; 0 || ss&gt;59 || es &lt; 0 || es&gt;59) flag = 0; if (flag) &#123; ans = (((eh - sh) * 60 + sm - em) * 60 + ss - es) / n; printf("%d:%d:%d\n", ans / 3600, ans / 60 % 60, ans % 60); &#125; else printf("提供的时间无效！\n");&#125; 1086 BISTU ACM报名了123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;using namespace std;int n, num, T = 0, F = 0;string s, name;char c;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); while (cin &gt;&gt; s &gt;&gt; n&amp;&amp;s != "END") &#123; int cnt = 0; bool cont = true; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; name &gt;&gt; c &gt;&gt; num; if (c == 'F') cnt++; if (num &lt; 3) cont = false; &#125; bool flag = false; if (('a' &lt;= s[0] &amp;&amp; s[0] &lt;= 'z' || 'A' &lt;= s[0] &amp;&amp; s[0] &lt;= 'Z') &amp;&amp; 3 &lt;= s.size() &amp;&amp; s.size() &lt;= 20) flag = true; if (flag&amp;&amp;cont &amp;&amp; 1 &lt;= n&amp;&amp;n &lt;= 3) &#123; cout &lt;&lt; s; if (cnt == n) &#123; cout &lt;&lt; "[F]"; F++; &#125; cout &lt;&lt; "合格！" &lt;&lt; endl; T++; &#125; else &#123; if (!flag) cout &lt;&lt; s &lt;&lt; "队名不合要求！" &lt;&lt; endl; else if (n &lt; 1 || n&gt;3) cout &lt;&lt; s &lt;&lt; "队伍人数不合要求！" &lt;&lt; endl; else cout &lt;&lt; s &lt;&lt; "队有人成绩不合格！" &lt;&lt; endl; &#125; &#125; cout &lt;&lt; T &lt;&lt; ' ' &lt;&lt; F &lt;&lt; endl;&#125; 1087 小张在干什么？12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;int sy, sm, sd, y, m, d;int check(const int y)&#123; return ((y % 4 == 0) &amp;&amp; (y % 100 != 0) || y % 400 == 0);&#125;int count(const int y, const int m, const int d)&#123; int cnt = d; for (int i = 1; i &lt; m; ++i) &#123; switch (i) &#123; case 1:case 3:case 5:case 7:case 8:case 10:case 12: cnt += 31; break; case 2: cnt += 28 + check(y); break; default: cnt += 30; &#125; &#125; return cnt;&#125;int main()&#123; scanf("%d-%d-%d", &amp;sy, &amp;sm, &amp;sd); while (~scanf("%d-%d-%d", &amp;y, &amp;m, &amp;d)) &#123; int sum = 0; for (int i = sy; i &lt; y; ++i) sum += 365 + check(i); switch ((sum - count(sy, sm, sd) + count(y, m, d)) % 7) &#123; case 0:case 1: printf("学英语\n"); break; case 2:case 3: printf("学数学\n"); break; case 4:case 5: printf("做AC\n"); break; default: printf("网游\n"); &#125; &#125;&#125; 1088 老师的烦恼1234567891011121314151617181920212223#include &lt;stdio.h&gt;int n;char s[100];int main()&#123; scanf("%d", &amp;n); while (n--) &#123; getchar(); scanf("%[^\n]", s); int end = 1; for (int i = 0; s[i] != '\0'; ++i) &#123; if (s[i] == ' ' &amp;&amp; !end) end = 1; if ('a' &lt;= s[i] &amp;&amp; s[i] &lt;= 'z'&amp;&amp;end) s[i] -= 32, end = 0; else if ('A' &lt;= s[i] &amp;&amp; s[i] &lt;= 'Z' &amp;&amp; !end) s[i] += 32; &#125; printf("%s\n", s); &#125;&#125; 1089 The Clocks1234567891011121314/*此题同1090，常规思路就是dfs暴搜，维护一个路径数组即可。稍微优化一下可以进行状态压缩，用一个数字记录下当前钟表的状态，另外9个数字分别代表9种操作，每次判断和调整都不需要遍历，只进行加减运算和判断大小就可以了。例如：9 9 126 6 66 3 6可以转化为334222212*/ 1090 时钟The Clocks123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;iostream&gt;#include &lt;string.h&gt;using namespace std;int clk[10], cnt[10], res[30];bool flag = false;void adjust(int n, int x)&#123; switch (n) &#123; case 1: clk[1] += x, clk[2] += x, clk[4] += x, clk[5] += x; break; case 2: clk[1] += x, clk[2] += x, clk[3] += x; break; case 3: clk[2] += x, clk[3] += x, clk[6] += x, clk[5] += x; break; case 4: clk[1] += x, clk[7] += x, clk[4] += x; break; case 5: clk[6] += x, clk[2] += x, clk[4] += x, clk[5] += x, clk[8] += x; break; case 6: clk[3] += x, clk[6] += x, clk[9] += x; break; case 7: clk[7] += x, clk[8] += x, clk[4] += x, clk[5] += x; break; case 8: clk[7] += x, clk[8] += x, clk[9] += x; break; case 9: clk[6] += x, clk[5] += x, clk[8] += x, clk[9] += x; break; &#125; for (int i = 1; i &lt;= 9; ++i) clk[i] %= 12;&#125;bool check()&#123; for (int i = 1; i &lt;= 9; ++i) if (clk[i]) return false; return true;&#125;void dfs(int n)&#123; if (!flag&amp;&amp;check()) &#123; flag = true; if (n &gt; 0) &#123; for (int i = 0; i &lt; n - 1; ++i) cout &lt;&lt; res[i] &lt;&lt; ' '; cout &lt;&lt; res[n - 1] &lt;&lt; endl; &#125; return; &#125; for (int i = !n ? 1 : res[n - 1]; i &lt;= 9 &amp;&amp; !flag; ++i) if (cnt[i] &lt;= 2) &#123; res[n] = i; adjust(i, 3); cnt[i]++; dfs(n + 1); adjust(i, -3); cnt[i]--; &#125;&#125;int main()&#123; for (int i = 1; i &lt;= 9; ++i) cin &gt;&gt; clk[i]; memset(cnt, 0, sizeof(cnt)); dfs(0);&#125; 1091 N皇后问题(final版)12 1092 N皇后问题(easy版)12 1093 N皇后问题(hard版)12 1094 辉辉的一天12 1095 Hidden ICPC12 1096 超大整数的加法12 1097 求N!的末尾0的个数12 1098 棋盘问题12 1099 Welcome to Code Jam12 1100 电子表格列序号转换12]]></content>
      <categories>
        <category>BISTU</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[newcoder regular contest 26]]></title>
    <url>%2Fpost%2Fbe09e36b.html</url>
    <content type="text"><![CDATA[牛客练习赛26 A-平面(找规律) 题目描述小a的平面上有n个X型不明物体，但是他不确定他们的位置。现在请你来确定他们的位置，使得划分形成的平面尽量多 输入描述:一个整数n，如题所示 输出描述:一个整数，表示最多把平面分成多少份 示例1输入2 输出11 说明 备注\(n\leq10^9\) 第k条线可以增加k个平面，第n个X可以增加4n-1个平面。求\(\sum_{i=1}^{2n}i\)，利用等差数列求和公式再加上原有的1个平面即为结果。 1234567891011#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll n;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; n; n *= 2; cout &lt;&lt; (1 + n)*n / 2 + 1 &lt;&lt; endl;&#125; B-烟花(概率DP) 题目描述小a有n个烟花，每个烟花代表着互不相同的颜色，对于第i个烟花，它有\(P_i\)的概率点燃，现在小a要去点燃它们，他想知道产生颜色的期望个数及产生恰好产生k种颜色的概率 输入描述:第一行两个整数n,k接下来一行n个数，第i个数\(P_i\)表示第i个烟花被点燃的概率 输出描述:输出有两行第一行表示产生不同颜色的期望个数第二行表示产生恰好k种颜色的概率以换行符分割 示例1输入3 20.5 0.25 0.75 输出1.50000.4062 说明第二问样例解释：(1,2):0.5*0.25*(1-0.75)=0.03125(1,2):0.5*(1-0.25)*0.75=0.28125(1,2):(1-0.5)*0.25*0.75=0.09375相加得0.40625 备注对于30%的数据：\(n\leq6,k\leq n\)对于100%的数据：\(n\leq10^5,k\leq2*10^2\)输出均保留4位小数,若你的答案误差与std不超过\(10^{-4}\)即为正确 第一行输出期望\(E(X)=\sum_{i=1}^{n}x_ip_i\)，每种颜色各一个，所以x=1，直接概率相加就可以。第二行输出dp[n,k]。[1,i]的烟花点燃了j个的概率为dp[i,j]，转移方程为dp[i][j] = dp[i - 1][j] * (1 - a[i]) + dp[i - 1][j - 1] * a[i]，需要考虑第i个未点燃和第i个点燃两种状态。 123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN = (int)1e5 + 5;int n, k;double a[MAXN], dp[MAXN][205], sum = 0;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cout.setf(ios::fixed); cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; a[i]; sum += a[i]; &#125; dp[0][0] = 1; for (int i = 1; i &lt;= n; ++i) &#123; dp[i][0] = dp[i - 1][0] * (1 - a[i]); for (int j = 1; j &lt;= k; ++j) dp[i][j] = dp[i - 1][j] * (1 - a[i]) + dp[i - 1][j - 1] * a[i]; &#125; cout &lt;&lt; setprecision(4) &lt;&lt; sum &lt;&lt; endl &lt;&lt; dp[n][k] &lt;&lt; endl;&#125; C-城市规划 题目描述小a的国家里有n个城市，其中第i和第i - 1个城市之间有无向道路连接，特殊的，第1个城市仅与第2个城市相连为了减轻道路维护负担，城市规划局局长MXT给出了m个要求，他想让小a断开一些道路，使得任意1 ≤ i ≤ m，城市xi不能到达城市yi，同时最小化断开道路的数量。 输入描述:第一行两个整数n, m，分别表示城市的数量和请求的数量接下来m行，每行两个整数x,y，表示需要使得x不能到达y 输出描述:输出一个整数，表示最小断开桥的数量 示例1输入4 21 32 4 输出1 说明可以断开(2, 3)城市之间的道路 示例2输入4 31 32 41 2 输出2 说明可以断开(1, 2) (2, 3)之间的道路 备注对于100%的数据：\(n\leq10^6,m\leq10^7\)本题不卡常数，请设计严格线性做法读入文件较大，请使用读入优化，本机调试时请使用文件输入输出由于nowcoder的编译器限制，如果需要在程序中开\(10^7\)级别的数组，可能会出现内存超限的情况，请使用new函数手动申请 12 D-xor序列 题目描述小a有n个数，他提出了一个很有意思的问题：他想知道对于任意的x, y，能否将x与这n个数中的任意多个数异或任意多次后变为y 输入描述:第一行为一个整数n，表示元素个数第二行一行包含n个整数，分别代表序列中的元素第三行为一个整数Q，表示询问次数接下来Q行，每行两个数x,y，含义如题所示 输出描述:输出Q行，若x可以变换为y，输出“YES”，否则输出“NO” 示例1输入51 2 3 4 536 72 13 8 输出YESYESNO 说明对于(6,7)来说，6可以先和3异或，再和2异或对于(2,1)来说，2可以和3异或对于(3,8)来说，3不论如何都不能变换为8 备注对于100%的数据，n，\(Q\leq10^5\)保证所有运算均在int范围内 1//线性基 技能点待加 E-树上路径 题目描述给出一个n个点的树，1号节点为根节点，每个点有一个权值你需要支持以下操作1.将以u为根的子树内节点(包括u)的权值加val2.将(u, v)路径上的节点权值加val3.询问(u, v)路径上节点的权值两两相乘的和 输入描述:第一行两个整数n, m，表示树的节点个数以及操作个数接下来一行n个数，表示每个节点的权值接下来n - 1行，每行两个整数(u, v)，表示(u, v)之间有边接下来m行开始有一个数opt，表示操作类型若opt = 1，接下来两个整数表示u, val若opt = 2，接下来三个整数表示(u, v), val若opt = 3，接下来两个整数表示(u, v)含义均如题所示 输出描述:对于每个第三种操作，输出一个数表示答案，对\(10^9+7\)取模 示例1输入3 85 3 11 21 33 1 23 1 33 2 31 1 22 1 3 23 1 23 1 33 2 3 输出155234545115 说明第一组询问结果：3 * 5 = 15第二组询问结果：1 * 5 = 5第三组询问结果：3 * 5 + 1 * 5 + 3 * 1 = 23 备注对于30%的数据，\(n,m\leq100\)对于100%的数据，\(n,m\leq10^5\)设\(a_i\)表示读入的第i个节点的权值以及每次修改的权值，保证\(a_i\leq10^4\)保证不会有负数 12 F-作物 题目描述山坡上有一个经济作物组成的序列序列长度为n，第i个植物成熟时间为pi,第i个植物与第i - 1 个植物距离为di一共有k个药农，每个药农将以1的速度从位置1出发, 你可以自由安排每个药农的出发时间，当一个药农走到某个位置时， 若该植物己经成熟，那么将其收获植物成熟后若未被收获每秒损失1的价值，求最小损失价值第一个植物的坐标为1 输入描述:第一行两个整数n, k第二行到第n+1行每行两个整数pi, di特别的，你可以认为d1没有意义 输出描述:一个非负整数表示最小代价 示例1输入8 41 22 33 44 55 66 77 88 9 输出19 说明样例解释：四个药农的出发时间分别为(1, -8, -19, -34) 备注对于100%的数据：\(n\leq2*10^5，k\leq2000，pi\leq10^9，di\leq10^4\)根据相对论，药农的出发时间可以为负！必须采摘所有植物，损失不可能为负数 12]]></content>
      <categories>
        <category>newcoder</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>DP</tag>
        <tag>CONTEST</tag>
        <tag>UNSOLVED</tag>
        <tag>找规律</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[newcoder OI test contest 1]]></title>
    <url>%2Fpost%2F4c37dc21.html</url>
    <content type="text"><![CDATA[牛客OI赛制测试赛1 A-斐波那契(找规律) 题目描述设f[i]表示斐波那契数论的第i项\(f[1]=1,f[2]=1,f[i]=f[i-1]+f[i-2]\)给定一个n求\(f[n-1]*f[n+1]-f[n]^2\) 输入描述:一个整数n 输出描述:一个整数，表示答案 示例1输入4 输出1 备注对于30%的数据，\(n\leq5\)对于50%的数据，\(n\leq10^5\)对于80%的数据，\(n\leq10^{15}\)对于100%的数据，\(2\leq n\leq10^{1000000}\) 找规律，秒杀，注意读入字符串 123456789101112#include &lt;bits/stdc++.h&gt;using namespace std;string n;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; n; if (n[n.size() - 1] &amp; 1) cout &lt;&lt; -1 &lt;&lt; endl; else cout &lt;&lt; 1 &lt;&lt; endl;&#125; B-送分题(水题) 题目描述对于一套题来说，没有一道送分题，就很不符合常理，但是我又懒得写送分题，所以你可以直接复制以下代码，即可ac本题. #include&lt; cstdio&gt;#include&lt; iostream&gt;using namespace std;int a,b,c; int main(){long long l=1,r=int(1e9)&lt;&gt;b;while(r-l&gt;1){c=(l+r)&gt;&gt;1;if(c-ba)r=c;else return printf(“%d\n”,c);} if(l!=r)return printf(“%d\n”,r); } 输入描述:输入共一行，两个整数a和b，范围在int之间 输出描述:输出一个整数表示答案 示例1输入5 123 输出128 备注喵喵喵 题面是A+B二分查找MDZZ版，输出A+B即可 123456789#include &lt;bits/stdc++.h&gt;using namespace std;int a, b;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; a + b &lt;&lt; endl;&#125; C-序列(模拟) 题目描述小a有n个数，他想把他们划分为连续的权值相等的k段，但他不知道这是否可行。每个数都必须被划分这个问题对他来说太难了，于是他把这个问题丢给了你。 输入描述:第一行为两个整数n,q，分别表示序列长度和询问个数。第二行有n个数，表示序列中的每个数。接下来的q行，每行包含一个数k，含义如题所示。 输出描述:输出q行，每行对应一个数Yes或者No，分别表示可行/不可行 示例1输入5 32 1 3 -1 4321 输出YesNoYes 备注对于30%的数据，\(n\leq10,q\leq20\)对于60%的数据，\(n\leq2000,q\leq2000\)对于100%的数据，\(n\leq100000,q\leq1000000\)设\(a_i\)表示数列中的第i个数，保证\(\sum a_i\leq10^{13}\)保证数据完全随机 模拟前判断一下sum能否被k整除，不能整除的肯定不能划分。说好的cin取消同步比scanf还快呢…换成scanf前T了三次 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = (int)1e5 + 5;typedef long long ll;ll n, q, a[MAXN], k, sum = 0;int main()&#123; scanf("%lld %lld", &amp;n, &amp;q); for (int i = 1; i &lt;= n; ++i) &#123; scanf("%lld", &amp;a[i]); sum += a[i]; &#125; while (q--) &#123; scanf("%lld", &amp;k); if (sum%k) printf("No\n"); else &#123; double avg = sum / (double)k, sm = 0, cnt = 0; for (int i = 1; i &lt;= n; ++i) &#123; sm += a[i]; if (sm == avg) &#123; sm = 0; cnt++; &#125; &#125; if (cnt == k) printf("Yes\n"); else printf("No\n"); &#125; &#125;&#125; D-小叶的巡查(DFS) 题目描述8102年，牛客系列竞赛空前繁荣。为了更好地管理竞赛，小叶决定巡查于各大城市之间，体察民情。所以，从一个城市马不停蹄地到另一个城市成了小叶最常做的事情。小叶有一个钱袋，用于存放往来城市间的路费。这个国家有一套优秀的交通方案，使得任何一个大城市都能从首都直接或者通过其他大城市间接到达。同时，如果不重复经过大城市，从首都到达每个大城市的方案都是唯一的。如果不在某个城市停下来修整，在连续行进过程中，小叶所花的路费与他已走过的距离有关，在走第x-1千米到第x千米这一千米中（x是整数），他花费的路费是x+10这么多。也就是说走1千米花费11，走2千米要花费23。因为国家力挺牛客系列竞赛，所以国家会给小叶报销全部的路费。现在组织想知道：小叶从某一个城市出发，中间不休息，到达另一个城市，所有可能花费的路费中最多是多少呢？ 输入描述:输入的第一行包含一个整数n，表示包括首都在内的城市数城市从1开始依次编号，1号城市为首都。接下来n-1行，描述高速路（高速路一定是n-1条）每行三个整数Pi, Qi, Di，表示城市Pi和城市Qi之间有一条高速路，长度为Di千米。 输出描述:输出一个整数，表示小叶最多花费的路费是多少。 示例1输入51 2 21 3 12 4 52 5 4 输出135 备注n&lt;23333 求树的直径，dfs或者bfs都可以，第一次求出距离当前点u最远的点v，第二次求出点距离点v最远的距离即为树的直径。 我们将一棵树T = (V, E)的直径定义为maxδ(u, v)(u,v ∈ V), 也就是说，树中所有最短路径距离的最大值即为树的直径 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN = (int)1e5 + 5;int n, P, Q, D, v = -1;vector&lt;pair&lt;int, int&gt;&gt; g[MAXN];bool vis[MAXN];ll maxLen = INT_MIN;void dfs(int start, ll len)&#123; if (len &gt; maxLen) &#123; maxLen = len; v = start; &#125; for (auto i : g[start]) &#123; if (vis[i.first] == false) &#123; vis[i.first] = true; len += i.second; dfs(i.first, len); vis[i.first] = false; len -= i.second; &#125; &#125;&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); memset(vis, false, sizeof(vis)); cin &gt;&gt; n; for (int i = 1; i &lt; n; ++i) &#123; cin &gt;&gt; P &gt;&gt; Q &gt;&gt; D; g[P].emplace_back(Q, D); g[Q].emplace_back(P, D); &#125; vis[1] = true; dfs(1, 0); vis[1] = false; vis[v] = true; dfs(v, 0); cout &lt;&lt; (1 + maxLen)*maxLen / 2 + maxLen * 10 &lt;&lt; endl;&#125; E- 旅行青蛙(LIS) 题目描述一只青蛙出去旅游，因为中国有一句古话说的好：“由简入奢易，由奢入俭难”，所以这只青蛙当看的当前景点比前面看过的景点差的时候，青蛙就会说“不开心”为了避免这只青蛙说“不开心”，并且使青蛙看的景点尽量的多，所以他请你帮忙给他安排一条线路，使青蛙可以看到尽量多的景点，并且不走回头路。 输入描述:第一行为一个整数n，表示景点的数量接下来n行，每行1个整数，分别表示第i个景点的质量 输出描述:一个整数，表示青蛙最多可以看到几个景点 示例1输入10318714101223301624 输出6 备注景点质量为1到n+23的整数10&lt;=n&lt;23 10%23&lt;=n&lt;233 30%233&lt;=n&lt;2333 60%2333&lt;=n&lt;23333 100% 求最长非严格上升子序列，这个算法相较于\(n^2\)算法快在了二分查找，用维护数组d，d[len]记录长度为len的子序列的最大的数字。若大于d[len]，则在下个len记录a[i]；若小于d[len]，则更新d中第一个大于a[i]的位置。更新的作用是在最大的数中找到最小的一个数，以便后面正确的更新。板子很简练，能理解的话，还是很容易看懂的:P 123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = (int)1e5 + 5;int n, a[MAXN], d[MAXN];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i]; if (!n) cout &lt;&lt; 0 &lt;&lt; endl; else &#123; int len = 1; d[1] = a[1]; for (int i = 2; i &lt;= n; ++i) d[a[i] &gt;= d[len] ? ++len : upper_bound(d + 1, d + 1 + len, a[i]) - d] = a[i]; cout &lt;&lt; len &lt;&lt; endl; &#125;&#125; F- 子序列 题目描述给出一个长度为n的序列，你需要计算出所有长度为k的子序列中，除最大最小数之外所有数的乘积相乘的结果 输入描述:第一行一个整数T，表示数据组数。对于每组数据，第一行两个整数N，k，含义如题所示接下来一行N个整数，表示给出的序列保证序列内的数互不相同 输出描述:对于每组数据，输出一个整数表示答案，对\(10^9+7\)取模每组数据之间以换行分割 示例1输入34 35 3 1 45 43 7 5 2 110 3100 1020 2050 102 12 235 4 57 32135 54354 输出14481000521918013 说明第一组数据解释所有长度为3的子序列为(5,3,1)(5,3,4)(3,1,4)(5,1,4)最终答案为3*4*3*4=144 备注对于30%的数据，\(T\leq10,N\leq100,k\leq N\)对于60%的数据，\(T\leq10,N\leq1000,k\leq N\)对于100%的数据，\(T\leq1000,N\leq1000,k\leq N\)保证序列中的元素互不相同且\(\leq10^6,k\ge3\) 1//容斥 技能点待加]]></content>
      <categories>
        <category>newcoder</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>CONTEST</tag>
        <tag>模拟</tag>
        <tag>UNSOLVED</tag>
        <tag>找规律</tag>
        <tag>DFS</tag>
        <tag>LIS</tag>
        <tag>线性基</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[newcoder OI test contest 2]]></title>
    <url>%2Fpost%2Fd53e8d9b.html</url>
    <content type="text"><![CDATA[牛客OI赛制测试赛2 A-无序组数(gcd) 题目描述给出一个二元组（A,B）求出无序二元组（a,b） 使得（a|A，b|B）的组数无序意思就是(a,b)和(b,a) 算一组. 输入描述:第一行数据组数 T（1≤T≤10000）接下来T行，每行两个正整数 A,B（1≤A,B≤10000） 输出描述:共T行，每行一个结果 示例1输入14 6 输出11 说明样例解释：二元组如下：(1,1)(1,2)(1,3)(1,6)(2,1)(2,2)(2,3)(2,6)(4,1)(4,2)(4,3)(4,6)共12组. 无序二元组如下：(1,1)(1,2)(1,3)(1,6)(2,2)(2,3)(2,6)(4,1)(4,2)(4,3)(4,6)共11组 暴力模拟+去重过了就没写其他方法了，但是这题更优雅的方法是分别求解A、B的因子数量和A、B的GCD，然后计算GCD的因子数量，等同于计算了A、B相同的因子个数。计算两数因子个数的积然后减去相同因子所组成的相同的元祖，结果就是答案了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN = (int)1e3 + 5;int T, a, b;vector&lt;int&gt; seq1, seq2;vector&lt;pair&lt;int, int&gt;&gt; ans;void factor(int n, int f = 1)&#123; for (int i = 1; i &lt;= sqrt(n); ++i) if (n % i == 0) &#123; if (f) &#123; seq1.emplace_back(i); seq1.emplace_back(n / i); &#125; else &#123; seq2.emplace_back(i); seq2.emplace_back(n / i); &#125; &#125;&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; T; while (T--) &#123; vector&lt;int&gt;().swap(seq1); vector&lt;int&gt;().swap(seq2); vector&lt;pair&lt;int, int&gt;&gt;().swap(ans); cin &gt;&gt; a &gt;&gt; b; factor(a); factor(b, 0); sort(seq1.begin(), seq1.end()); seq1.erase(unique(seq1.begin(), seq1.end()), seq1.end()); sort(seq2.begin(), seq2.end()); seq2.erase(unique(seq2.begin(), seq2.end()), seq2.end()); for (int i = 0; i &lt; (signed)seq1.size(); ++i) for (int j = 0; j &lt; (signed)seq2.size(); ++j) &#123; if (seq1[i] &lt; seq2[j]) ans.emplace_back(seq1[i], seq2[j]); else ans.emplace_back(seq2[j], seq1[i]); &#125; sort(ans.begin(), ans.end()); ans.erase(unique(ans.begin(), ans.end()), ans.end()); cout &lt;&lt; ans.size() &lt;&lt; endl; &#125;&#125; B-路径数量(矩阵快速幂) 题目描述给出一个 n * n 的邻接矩阵A.A是一个01矩阵 .A[i][j] = 1表示i号点和j号点之间有长度为1的边直接相连.求出从 1 号点 到 n 号点长度为k的路径的数目. 输入描述:第1行两个数n,k (20 ≤n ≤ 30,1 ≤ k ≤ 10)第2行至第n+1行，为一个邻接矩阵 输出描述:题目中所求的数目 示例1输入4 20 1 1 01 0 0 11 0 0 10 1 1 0 输出2 说明 样例如图:第一条路径：1-2-4第二条路径：1-3-4 矩阵\(A^n[i][j]\)表示从i到j距离为n的路径数量。题目求长度为k的路径数量即\(A^k[1][n]\) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN = (int)1e2 + 5;struct Mat&#123; ll n, m[MAXN][MAXN]; Mat() &#123; n = 0; memset(m, 0, sizeof(m)); &#125;&#125;;Mat mul(Mat m1, Mat m2)&#123; Mat ret; ret.n = m1.n; for (int i = 1; i &lt;= ret.n; ++i) for (int j = 1; j &lt;= ret.n; ++j) for (int k = 1; k &lt;= ret.n; ++k) if (m1.m[i][k] &amp;&amp; m2.m[k][j]) ret.m[i][j] += (m1.m[i][k] * m2.m[k][j]); return ret;&#125;Mat quickmul(Mat m, ll n)&#123; Mat ret; ret.n = m.n; for (int i = 1; i &lt;= n; ++i) ret.m[i][i] = 1; while (n) &#123; if (n &amp; 1) ret = mul(ret, m); m = mul(m, m); n &gt;&gt;= 1; &#125; return ret;&#125;int n, k;Mat a;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; n &gt;&gt; k; a.n = n; for (int i = 1; i &lt;= a.n; ++i) for (int j = 1; j &lt;= a.n; ++j) cin &gt;&gt; a.m[i][j]; a = quickmul(a, k); cout &lt;&lt; a.m[1][n] &lt;&lt; endl;&#125; C-数列下标(暴力) 题目描述给出一个数列 A，求出一个数列B.其中Bi表示 数列A中Ai右边第一个比Ai大的数的下标(从1开始计数),没有找到这一个下标Bi就为0,输出数列B 输入描述:第一行1个数字 n (n ≤ 10000)第二行n个数字第 i 个数字为 Ai (0 ≤ Ai ≤ 1000000000) 输出描述:一共一行，第 i 个数和第 i+1 个数中间用空格隔开. 示例1输入63 2 6 1 1 2 输出3 3 0 6 6 0 说明样例不用解释 暴力即可，但是比赛这题数据有点问题，1e4是过不了的，换成1e5就过了，QAQ 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN = (int)1e5 + 5;int n, a[MAXN], ans[MAXN];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i]; for (int i = 1; i &lt; n; ++i) &#123; int idx = 0; for (int j = i + 1; j &lt;= n; ++j) if (a[i] &lt; a[j]) &#123; idx = j; break; &#125; ans[i] = idx; &#125; ans[n] = 0; for (int i = 1; i &lt;= n; ++i) cout &lt;&lt; ans[i] &lt;&lt; ' '; cout &lt;&lt; endl;&#125; D-星光晚餐(找规律) 题目描述Johnson先将天上n个星星排成一排，起初它们都是暗的。 他告诉他的妹子，他将挥动n次魔法棒，第i次挥动会将编号为i的正整数倍的星星的亮暗反转，即亮的星星转暗，暗的星星转亮。 Johnson想问Nancy，最终会有多少个星星依旧闪亮在天空。 输入描述:一个整数n，含义请见题目描述。 输出描述:一个整数ans，即n次操作后会有多少个星星依旧闪亮。 示例1输入3 输出1 示例2输入7 输出2 备注对于60%的数据：n ≤ \(2×10^6\)对于100%的数据：n ≤ \(10^{18}\) 打表找了一下规律发现正好符合sqrt(n)向下取整。 12345678910#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll n;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; n; cout &lt;&lt; (ll)floor(sqrt(n)) &lt;&lt; endl;&#125; E- 括号序列(模拟) 题目描述给定括号长度N，给出一串括号（只包含小括号），计算出最少的交换（两两交换）次数，使整个括号序列匹配。我们认为一个括号匹配，即对任意一个’)’，在其左侧都有一个’(‘与它匹配，且他们形成一一映射关系。 输入描述:第一行：整数N，表示括号序列长度第二行：一个字符串，表示括号 输出描述:一个整数，表示最少的交换次数 示例1输入6(()))( 输出1 示例2输入6)))((( 输出2 说明对于80%的数据：n ≤ 3000对于100%的数据，n ≤ \(5×10^{6}\) 括号字符串中已经匹配的括号不需要交换，那么只需要统计一下未匹配的括号的数量，交换一次可以消去4个括号。 1234567891011121314151617#include&lt;bits/stdc++.h&gt;using namespace std;int n, l = 0, r = 0;string s;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; n &gt;&gt; s; for (int i = 0; i &lt; (signed)s.size(); ++i) &#123; if (s[i] == '(') l++; if (s[i] == ')'&amp;&amp;l &gt; r) r++; &#125; cout &lt;&lt; ceil((double)(n - r * 2) / 4) &lt;&lt; endl;&#125; F- 括号序列(打表) 题目描述输入一个整数X，求一个整数N，使得\(N!\)恰好大于\(X^X\)。 输入描述:第一行：一个整数X 输出描述:第一行：一个整数N 示例1输入7 输出10 备注每个测试点所对应的X满足：第i个测试点输入的值为第i-1个测试点输入的值乘以10再加上7。特别的，第一个测试点所输入的值为7。提示：数据共有10组。 数据较大时肯定不能通过直接比较的方法来计算了，计算位数是一个不错的方法，分别计算\(N!\)的每一个数字，\(N!=\prod_{i=1}^{N}lgi\)，\(X\)的位数为\(lgX\)，\(X^X\)的位数为\(lgX^X\)，化简之后为\(XlgX\)。由于备注已经说明测试数据了，打个表结果就出来了，就是算到最后两个时间可能会稍微长一点… 我的代码:1234567891011#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;string X;ll a[10] = &#123; 10,94,892,8640,84657,834966,8267019,82052137,815725636,8118965902 &#125;;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; X; cout &lt;&lt; a[X.size() - 1] &lt;&lt; endl;&#125; 利用Stirling公式 \(n!\approx\sqrt{2\pi n}(\frac{n}{e})^n\):1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef long double lb;using namespace std;lb N, X;ll l = 1, r = (ll)1e18, ans;bool check(lb N)&#123; N = log(2 * acos(-1) * N) / 2 + N * log(N / exp(1)); if (N &gt; X) return true; return false;&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; X; X *= log(X); while (l &lt;= r) &#123; ll mid = (l + r) &gt;&gt; 1; if (check((lb)mid)) &#123; ans = mid; r = mid - 1; &#125; else l = mid + 1; &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>newcoder</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>CONTEST</tag>
        <tag>ALL KILLED</tag>
        <tag>gcd</tag>
        <tag>矩阵快速幂</tag>
        <tag>模拟</tag>
        <tag>打表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 1028 Ignatius and the Princess III(DP入门)]]></title>
    <url>%2Fpost%2F511e6933.html</url>
    <content type="text"><![CDATA[HDU1028 Problem Description“Well, it seems the first problem is too easy. I will let you know how foolish you are later.” feng5166 says.“The second problem is, given an positive integer N, we define an equation like this: N=a[1]+a[2]+a[3]+…+a[m]; a[i]&gt;0,1&lt;=m&lt;=N;My question is how many different equations you can find for a given N.For example, assume N is 4, we can find: 4 = 4; 4 = 3 + 1; 4 = 2 + 2; 4 = 2 + 1 + 1; 4 = 1 + 1 + 1 + 1;so the result is 5 when N is 4. Note that “4 = 3 + 1” and “4 = 1 + 3” is the same in this problem. Now, you do it!” InputThe input contains several test cases. Each test case contains a positive integer N(1&lt;=N&lt;=120) which is mentioned above. The input is terminated by the end of file. OutputFor each test case, you have to output a line contains an integer P which indicate the different equations you have found. Sample Input41020 Sample Output542627 大致题意，一个数n可以拆分为[1, m]个大于0的整数相加，输入整数n，输出有多少种相加的方法，其实就是整数划分。 参考了这篇博客 https://blog.csdn.net/l2533636371/article/details/78077640想了很久，规律也找出来了，但是没能总结出状态转移方程，代码很精巧，值得学习。 123456789101112131415#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN = (int)1e3 + 5;int N, dp[MAXN];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); memset(dp, 0, sizeof(dp)); dp[0] = 1; for (int i = 1; i &lt;= 120; ++i) for (int j = 0; i + j &lt;= 120; ++j) dp[i + j] += dp[j]; while (cin &gt;&gt; N) cout &lt;&lt; dp[N] &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>HDU</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>DP</tag>
      </tags>
  </entry>
</search>
