<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[newcoder OI test contest 2]]></title>
    <url>%2Fpost%2Fd53e8d9b.html</url>
    <content type="text"><![CDATA[牛客OI赛制测试赛2 A-无序组数(GCD) 题目描述给出一个二元组（A,B）求出无序二元组（a,b） 使得（a|A，b|B）的组数无序意思就是(a,b)和(b,a) 算一组. 输入描述:第一行数据组数 T（1≤T≤10000）接下来T行，每行两个正整数 A,B（1≤A,B≤10000） 输出描述:共T行，每行一个结果 示例1输入14 6 输出11 说明样例解释：二元组如下：(1,1)(1,2)(1,3)(1,6)(2,1)(2,2)(2,3)(2,6)(4,1)(4,2)(4,3)(4,6)共12组. 无序二元组如下：(1,1)(1,2)(1,3)(1,6)(2,2)(2,3)(2,6)(4,1)(4,2)(4,3)(4,6)共11组 暴力模拟+去重过了就没写其他方法了，但是这题更优雅的方法是分别求解A、B的因子数量和A、B的GCD，然后计算GCD的因子数量，等同于计算了A、B相同的因子个数。计算两数因子个数的积然后减去相同因子所组成的相同的元祖，结果就是答案了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN = (int)1e3 + 5;int T, a, b;vector&lt;int&gt; seq1, seq2;vector&lt;pair&lt;int, int&gt;&gt; ans;void factor(int n, int f = 1)&#123; for (int i = 1; i &lt;= sqrt(n); ++i) if (n % i == 0) &#123; if (f) &#123; seq1.emplace_back(i); seq1.emplace_back(n / i); &#125; else &#123; seq2.emplace_back(i); seq2.emplace_back(n / i); &#125; &#125;&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; T; while (T--) &#123; vector&lt;int&gt;().swap(seq1); vector&lt;int&gt;().swap(seq2); vector&lt;pair&lt;int, int&gt;&gt;().swap(ans); cin &gt;&gt; a &gt;&gt; b; factor(a); factor(b, 0); sort(seq1.begin(), seq1.end()); seq1.erase(unique(seq1.begin(), seq1.end()), seq1.end()); sort(seq2.begin(), seq2.end()); seq2.erase(unique(seq2.begin(), seq2.end()), seq2.end()); for (int i = 0; i &lt; (signed)seq1.size(); ++i) for (int j = 0; j &lt; (signed)seq2.size(); ++j) &#123; if (seq1[i] &lt; seq2[j]) ans.emplace_back(seq1[i], seq2[j]); else ans.emplace_back(seq2[j], seq1[i]); &#125; sort(ans.begin(), ans.end()); ans.erase(unique(ans.begin(), ans.end()), ans.end()); cout &lt;&lt; ans.size() &lt;&lt; endl; &#125;&#125; B-路径数量(矩阵快速幂) 题目描述给出一个 n * n 的邻接矩阵A.A是一个01矩阵 .A[i][j] = 1表示i号点和j号点之间有长度为1的边直接相连.求出从 1 号点 到 n 号点长度为k的路径的数目. 输入描述:第1行两个数n,k (20 ≤n ≤ 30,1 ≤ k ≤ 10)第2行至第n+1行，为一个邻接矩阵 输出描述:题目中所求的数目 示例1输入4 20 1 1 01 0 0 11 0 0 10 1 1 0 输出2 说明 样例如图:第一条路径：1-2-4第二条路径：1-3-4 矩阵\(A^n[i][j]\)表示从i到j距离为n的路径数量。题目求长度为k的路径数量即\(A^k[1][n]\) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN = (int)1e2 + 5;struct Mat&#123; ll n, m[MAXN][MAXN]; Mat() &#123; n = 0; memset(m, 0, sizeof(m)); &#125;&#125;;Mat mul(Mat m1, Mat m2)&#123; Mat ret; ret.n = m1.n; for (int i = 1; i &lt;= ret.n; ++i) for (int j = 1; j &lt;= ret.n; ++j) for (int k = 1; k &lt;= ret.n; ++k) if (m1.m[i][k] &amp;&amp; m2.m[k][j]) ret.m[i][j] += (m1.m[i][k] * m2.m[k][j]); return ret;&#125;Mat quickmul(Mat m, ll n)&#123; Mat ret; ret.n = m.n; for (int i = 1; i &lt;= n; ++i) ret.m[i][i] = 1; while (n) &#123; if (n &amp; 1) ret = mul(ret, m); m = mul(m, m); n &gt;&gt;= 1; &#125; return ret;&#125;int n, k;Mat a;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; n &gt;&gt; k; a.n = n; for (int i = 1; i &lt;= a.n; ++i) for (int j = 1; j &lt;= a.n; ++j) cin &gt;&gt; a.m[i][j]; a = quickmul(a, k); cout &lt;&lt; a.m[1][n] &lt;&lt; endl;&#125; C-数列下标(暴力) 题目描述给出一个数列 A，求出一个数列B.其中Bi表示 数列A中Ai右边第一个比Ai大的数的下标(从1开始计数),没有找到这一个下标Bi就为0,输出数列B 输入描述:第一行1个数字 n (n ≤ 10000)第二行n个数字第 i 个数字为 Ai (0 ≤ Ai ≤ 1000000000) 输出描述:一共一行，第 i 个数和第 i+1 个数中间用空格隔开. 示例1输入63 2 6 1 1 2 输出3 3 0 6 6 0 说明样例不用解释 暴力即可，但是比赛这题数据有点问题，1e4是过不了的，换成1e5就过了，QAQ 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN = (int)1e5 + 5;int n, a[MAXN], ans[MAXN];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i]; for (int i = 1; i &lt; n; ++i) &#123; int idx = 0; for (int j = i + 1; j &lt;= n; ++j) if (a[i] &lt; a[j]) &#123; idx = j; break; &#125; ans[i] = idx; &#125; ans[n] = 0; for (int i = 1; i &lt;= n; ++i) cout &lt;&lt; ans[i] &lt;&lt; ' '; cout &lt;&lt; endl;&#125; D-星光晚餐(找规律) 题目描述Johnson先将天上n个星星排成一排，起初它们都是暗的。 他告诉他的妹子，他将挥动n次魔法棒，第i次挥动会将编号为i的正整数倍的星星的亮暗反转，即亮的星星转暗，暗的星星转亮。 Johnson想问Nancy，最终会有多少个星星依旧闪亮在天空。 输入描述:一个整数n，含义请见题目描述。 输出描述:一个整数ans，即n次操作后会有多少个星星依旧闪亮。 示例1输入3 输出1 示例2输入7 输出2 备注对于60%的数据：n ≤ \(2×10^6\)对于100%的数据：n ≤ \(10^{18}\) 打表找了一下规律发现正好符合sqrt(n)向下取整。 12345678910#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll n;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; n; cout &lt;&lt; (ll)floor(sqrt(n)) &lt;&lt; endl;&#125; E- 括号序列(模拟) 题目描述给定括号长度N，给出一串括号（只包含小括号），计算出最少的交换（两两交换）次数，使整个括号序列匹配。我们认为一个括号匹配，即对任意一个’)’，在其左侧都有一个’(‘与它匹配，且他们形成一一映射关系。 输入描述:第一行：整数N，表示括号序列长度第二行：一个字符串，表示括号 输出描述:一个整数，表示最少的交换次数 示例1输入6(()))( 输出1 示例2输入6)))((( 输出2 说明对于80%的数据：n ≤ 3000对于100%的数据，n ≤ \(5×10^{6}\) 括号字符串中已经匹配的括号不需要交换，那么只需要统计一下未匹配的括号的数量，交换一次可以消去4个括号。 1234567891011121314151617#include&lt;bits/stdc++.h&gt;using namespace std;int n, l = 0, r = 0;string s;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; n &gt;&gt; s; for (int i = 0; i &lt; (signed)s.size(); ++i) &#123; if (s[i] == '(') l++; if (s[i] == ')'&amp;&amp;l &gt; r) r++; &#125; cout &lt;&lt; ceil((double)(n - r * 2) / 4) &lt;&lt; endl;&#125; F- 括号序列(打表) 题目描述输入一个整数X，求一个整数N，使得\(N!\)恰好大于\(X^X\)。 输入描述:第一行：一个整数X 输出描述:第一行：一个整数N 示例1输入7 输出10 备注每个测试点所对应的X满足：第i个测试点输入的值为第i-1个测试点输入的值乘以10再加上7。特别的，第一个测试点所输入的值为7。提示：数据共有10组。 数据较大时肯定不能通过直接比较的方法来计算了，计算位数是一个不错的方法，分别计算\(N!\)的每一个数字，\(N!=\prod_{i=1}^{N}lgi\)，\(X\)的位数为\(lgX\)，\(X^X\)的位数为\(lgX^X\)，化简之后为\(XlgX\)。由于备注已经说明测试数据了，打个表结果就出来了，就是算到最后两个时间可能会稍微长一点… 我的代码:1234567891011#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;string X;ll a[10] = &#123; 10,94,892,8640,84657,834966,8267019,82052137,815725636,8118965902 &#125;;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; X; cout &lt;&lt; a[X.size() - 1] &lt;&lt; endl;&#125; 利用Stirling公式 \(n!\approx\sqrt{2\pi n}(\frac{n}{e})^n\):1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef long double lb;using namespace std;lb N, X;ll l = 1, r = (ll)1e18, ans;bool check(lb N)&#123; N = log(2 * acos(-1) * N) / 2 + N * log(N / exp(1)); if (N &gt; X) return true; return false;&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; X; X *= log(X); while (l &lt;= r) &#123; ll mid = (l + r) &gt;&gt; 1; if (check((lb)mid)) &#123; ans = mid; r = mid - 1; &#125; else l = mid + 1; &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>newcoder</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>CONTEST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 1028 Ignatius and the Princess III(DP入门)]]></title>
    <url>%2Fpost%2F511e6933.html</url>
    <content type="text"><![CDATA[HDU1028 Problem Description“Well, it seems the first problem is too easy. I will let you know how foolish you are later.” feng5166 says.“The second problem is, given an positive integer N, we define an equation like this: N=a[1]+a[2]+a[3]+…+a[m]; a[i]&gt;0,1&lt;=m&lt;=N;My question is how many different equations you can find for a given N.For example, assume N is 4, we can find: 4 = 4; 4 = 3 + 1; 4 = 2 + 2; 4 = 2 + 1 + 1; 4 = 1 + 1 + 1 + 1;so the result is 5 when N is 4. Note that “4 = 3 + 1” and “4 = 1 + 3” is the same in this problem. Now, you do it!” InputThe input contains several test cases. Each test case contains a positive integer N(1&lt;=N&lt;=120) which is mentioned above. The input is terminated by the end of file. OutputFor each test case, you have to output a line contains an integer P which indicate the different equations you have found. Sample Input41020 Sample Output542627 大致题意，一个数n可以拆分为[1, m]个大于0的整数相加，输入整数n，输出有多少种相加的方法，其实就是整数划分。 参考了这篇博客 https://blog.csdn.net/l2533636371/article/details/78077640想了很久，规律也找出来了，但是没能总结出状态转移方程，代码很精巧，值得学习。 123456789101112131415#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN = (int)1e3 + 5;int N, dp[MAXN];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); memset(dp, 0, sizeof(dp)); dp[0] = 1; for (int i = 1; i &lt;= 120; ++i) for (int j = 0; i + j &lt;= 120; ++j) dp[i + j] += dp[j]; while (cin &gt;&gt; N) cout &lt;&lt; dp[N] &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>HDU</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>DP</tag>
      </tags>
  </entry>
</search>
