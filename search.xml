<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HDU 1028 Ignatius and the Princess III(DP入门)]]></title>
    <url>%2Fpost%2F511e6933.html</url>
    <content type="text"><![CDATA[Problem Description“Well, it seems the first problem is too easy. I will let you know how foolish you are later.” feng5166 says. “The second problem is, given an positive integer N, we define an equation like this: N=a[1]+a[2]+a[3]+…+a[m]; a[i]&gt;0,1&lt;=m&lt;=N;My question is how many different equations you can find for a given N.For example, assume N is 4, we can find: 4 = 4; 4 = 3 + 1; 4 = 2 + 2; 4 = 2 + 1 + 1; 4 = 1 + 1 + 1 + 1;so the result is 5 when N is 4. Note that “4 = 3 + 1” and “4 = 1 + 3” is the same in this problem. Now, you do it!” InputThe input contains several test cases. Each test case contains a positive integer N(1&lt;=N&lt;=120) which is mentioned above. The input is terminated by the end of file. OutputFor each test case, you have to output a line contains an integer P which indicate the different equations you have found. Sample Input41020 Sample Output542627 大致题意，一个数n可以拆分为[1, m]个大于0的整数相加，输入整数n，输出有多少种相加的方法，其实就是整数划分。 参考了这篇博客 https://blog.csdn.net/l2533636371/article/details/78077640想了很久，规律也找出来了，但是没能总结出状态转移方程，代码很精巧，值得学习。 123456789101112131415#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN = (int)1e3 + 5;int N, dp[MAXN];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); memset(dp, 0, sizeof(dp)); dp[0] = 1; for (int i = 1; i &lt;= 120; ++i) for (int j = 0; i + j &lt;= 120; ++j) dp[i + j] += dp[j]; while (cin &gt;&gt; N) cout &lt;&lt; dp[N] &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>HDU</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>DP</tag>
      </tags>
  </entry>
</search>
