<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[newcoder OI test contest 1]]></title>
    <url>%2Fpost%2F4c37dc21.html</url>
    <content type="text"><![CDATA[牛客OI赛制测试赛1 A-斐波那契(找规律) 题目描述设f[i]表示斐波那契数论的第i项\(f[1]=1,f[2]=1,f[i]=f[i-1]+f[i-2]\)给定一个n求\(f[n-1]*f[n+1]-f[n]^2\) 输入描述:一个整数n 输出描述:一个整数，表示答案 示例1输入4 输出1 备注对于30%的数据，\(n\leq5\)对于50%的数据，\(n\leq10^5\)对于80%的数据，\(n\leq10^{15}\)对于100%的数据，\(2\leq n\leq10^{1000000}\) 找规律，秒杀，注意读入字符串 123456789101112#include &lt;bits/stdc++.h&gt;using namespace std;string n;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; n; if (n[n.size() - 1] &amp; 1) cout &lt;&lt; -1 &lt;&lt; endl; else cout &lt;&lt; 1 &lt;&lt; endl;&#125; B-送分题(水题) 题目描述对于一套题来说，没有一道送分题，就很不符合常理，但是我又懒得写送分题，所以你可以直接复制以下代码，即可ac本题. #include&lt; cstdio&gt;#include&lt; iostream&gt;using namespace std;int a,b,c; int main(){long long l=1,r=int(1e9)&lt;&gt;b;while(r-l&gt;1){c=(l+r)&gt;&gt;1;if(c-ba)r=c;else return printf(“%d\n”,c);} if(l!=r)return printf(“%d\n”,r); } 输入描述:输入共一行，两个整数a和b，范围在int之间 输出描述:输出一个整数表示答案 示例1输入5 123 输出128 备注喵喵喵 题面是A+B二分查找MDZZ版，输出A+B即可 123456789#include &lt;bits/stdc++.h&gt;using namespace std;int a, b;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; a + b &lt;&lt; endl;&#125; C-序列(模拟) 题目描述小a有n个数，他想把他们划分为连续的权值相等的k段，但他不知道这是否可行。每个数都必须被划分这个问题对他来说太难了，于是他把这个问题丢给了你。 输入描述:第一行为两个整数n,q，分别表示序列长度和询问个数。第二行有n个数，表示序列中的每个数。接下来的q行，每行包含一个数k，含义如题所示。 输出描述:输出q行，每行对应一个数Yes或者No，分别表示可行/不可行 示例1输入5 32 1 3 -1 4321 输出YesNoYes 备注对于30%的数据，\(n\leq10,q\leq20\)对于60%的数据，\(n\leq2000,q\leq2000\)对于100%的数据，\(n\leq100000,q\leq1000000\)设\(a_i\)表示数列中的第i个数，保证\(\sum a_i\leq10^{13}\)保证数据完全随机 模拟前判断一下sum能否被k整除，不能整除的肯定不能划分。说好的cin取消同步比scanf还快呢…换成scanf前T了三次QAQ牛客绝对是windows判题 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = (int)1e5 + 5;typedef long long ll;ll n, q, a[MAXN], k, sum = 0;int main()&#123; scanf("%lld %lld", &amp;n, &amp;q); for (int i = 1; i &lt;= n; ++i) &#123; scanf("%lld", &amp;a[i]); sum += a[i]; &#125; while (q--) &#123; scanf("%lld", &amp;k); if (sum%k) printf("No\n"); else &#123; double avg = sum / (double)k, sm = 0, cnt = 0; for (int i = 1; i &lt;= n; ++i) &#123; sm += a[i]; if (sm == avg) &#123; sm = 0; cnt++; &#125; &#125; if (cnt == k) printf("Yes\n"); else printf("No\n"); &#125; &#125;&#125; D-小叶的巡查(DFS) 题目描述8102年，牛客系列竞赛空前繁荣。为了更好地管理竞赛，小叶决定巡查于各大城市之间，体察民情。所以，从一个城市马不停蹄地到另一个城市成了小叶最常做的事情。小叶有一个钱袋，用于存放往来城市间的路费。这个国家有一套优秀的交通方案，使得任何一个大城市都能从首都直接或者通过其他大城市间接到达。同时，如果不重复经过大城市，从首都到达每个大城市的方案都是唯一的。如果不在某个城市停下来修整，在连续行进过程中，小叶所花的路费与他已走过的距离有关，在走第x-1千米到第x千米这一千米中（x是整数），他花费的路费是x+10这么多。也就是说走1千米花费11，走2千米要花费23。因为国家力挺牛客系列竞赛，所以国家会给小叶报销全部的路费。现在组织想知道：小叶从某一个城市出发，中间不休息，到达另一个城市，所有可能花费的路费中最多是多少呢？ 输入描述:输入的第一行包含一个整数n，表示包括首都在内的城市数城市从1开始依次编号，1号城市为首都。接下来n-1行，描述高速路（高速路一定是n-1条）每行三个整数Pi, Qi, Di，表示城市Pi和城市Qi之间有一条高速路，长度为Di千米。 输出描述:输出一个整数，表示小叶最多花费的路费是多少。 示例1输入51 2 21 3 12 4 52 5 4 输出135 备注n&lt;23333 求树的直径，dfs或者bfs都可以，第一次求出距离当前点u最远的点v，第二次求出点距离点v最远的距离即为树的直径。 我们将一棵树T = (V, E)的直径定义为maxδ(u, v)(u,v ∈ V), 也就是说，树中所有最短路径距离的最大值即为树的直径 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN = (int)1e5 + 5;int n, P, Q, D, v = -1;vector&lt;pair&lt;int, int&gt;&gt; g[MAXN];bool vis[MAXN];ll maxLen = INT_MIN;void dfs(int start, ll len)&#123; if (len &gt; maxLen) &#123; maxLen = len; v = start; &#125; for (auto i : g[start]) &#123; if (vis[i.first] == false) &#123; vis[i.first] = true; len += i.second; dfs(i.first, len); vis[i.first] = false; len -= i.second; &#125; &#125;&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); memset(vis, false, sizeof(vis)); cin &gt;&gt; n; for (int i = 1; i &lt; n; ++i) &#123; cin &gt;&gt; P &gt;&gt; Q &gt;&gt; D; g[P].emplace_back(Q, D); g[Q].emplace_back(P, D); &#125; vis[1] = true; dfs(1, 0); vis[1] = false; vis[v] = true; dfs(v, 0); cout &lt;&lt; (1 + maxLen)*maxLen / 2 + maxLen * 10 &lt;&lt; endl;&#125; E- 旅行青蛙 题目描述一只青蛙出去旅游，因为中国有一句古话说的好：“由简入奢易，由奢入俭难”，所以这只青蛙当看的当前景点比前面看过的景点差的时候，青蛙就会说“不开心”为了避免这只青蛙说“不开心”，并且使青蛙看的景点尽量的多，所以他请你帮忙给他安排一条线路，使青蛙可以看到尽量多的景点，并且不走回头路。 输入描述:第一行为一个整数n，表示景点的数量接下来n行，每行1个整数，分别表示第i个景点的质量 输出描述:一个整数，表示青蛙最多可以看到几个景点 示例1输入10318714101223301624 输出6 备注景点质量为1到n+23的整数10&lt;=n&lt;23 10%23&lt;=n&lt;233 30%233&lt;=n&lt;2333 60%2333&lt;=n&lt;23333 100% 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = (int)1e5 + 5;int n, a[MAXN], d[MAXN], len = 1;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i]; if (!n) cout &lt;&lt; 0 &lt;&lt; endl; else &#123; d[1] = a[1]; for (int i = 2; i &lt;= n; ++i) &#123; if (a[i] &gt;= d[len]) d[++len] = a[i]; else &#123; int j = upper_bound(d + 1, d + len + 1, a[i]) - d; d[j] = a[i]; &#125; &#125; cout &lt;&lt; len &lt;&lt; endl; &#125;&#125; F- 子序列 题目描述给出一个长度为n的序列，你需要计算出所有长度为k的子序列中，除最大最小数之外所有数的乘积相乘的结果 输入描述:第一行一个整数T，表示数据组数。对于每组数据，第一行两个整数N，k，含义如题所示接下来一行N个整数，表示给出的序列保证序列内的数互不相同 输出描述:对于每组数据，输出一个整数表示答案，对\(10^9+7\)取模每组数据之间以换行分割 示例1输入34 35 3 1 45 43 7 5 2 110 3100 1020 2050 102 12 235 4 57 32135 54354 输出14481000521918013 说明第一组数据解释所有长度为3的子序列为(5,3,1)(5,3,4)(3,1,4)(5,1,4)最终答案为3*4*3*4=144 备注对于30%的数据，\(T\leq10,N\leq100,k\leq N\)对于60%的数据，\(T\leq10,N\leq1000,k\leq N\)对于100%的数据，\(T\leq1000,N\leq1000,k\leq N\)保证序列中的元素互不相同且\(\leq10^6,k\ge3\) 12]]></content>
      <categories>
        <category>newcoder</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>CONTEST</tag>
        <tag>模拟</tag>
        <tag>UNSOLVED</tag>
        <tag>找规律</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[newcoder OI test contest 2]]></title>
    <url>%2Fpost%2Fd53e8d9b.html</url>
    <content type="text"><![CDATA[牛客OI赛制测试赛2 A-无序组数(gcd) 题目描述给出一个二元组（A,B）求出无序二元组（a,b） 使得（a|A，b|B）的组数无序意思就是(a,b)和(b,a) 算一组. 输入描述:第一行数据组数 T（1≤T≤10000）接下来T行，每行两个正整数 A,B（1≤A,B≤10000） 输出描述:共T行，每行一个结果 示例1输入14 6 输出11 说明样例解释：二元组如下：(1,1)(1,2)(1,3)(1,6)(2,1)(2,2)(2,3)(2,6)(4,1)(4,2)(4,3)(4,6)共12组. 无序二元组如下：(1,1)(1,2)(1,3)(1,6)(2,2)(2,3)(2,6)(4,1)(4,2)(4,3)(4,6)共11组 暴力模拟+去重过了就没写其他方法了，但是这题更优雅的方法是分别求解A、B的因子数量和A、B的GCD，然后计算GCD的因子数量，等同于计算了A、B相同的因子个数。计算两数因子个数的积然后减去相同因子所组成的相同的元祖，结果就是答案了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN = (int)1e3 + 5;int T, a, b;vector&lt;int&gt; seq1, seq2;vector&lt;pair&lt;int, int&gt;&gt; ans;void factor(int n, int f = 1)&#123; for (int i = 1; i &lt;= sqrt(n); ++i) if (n % i == 0) &#123; if (f) &#123; seq1.emplace_back(i); seq1.emplace_back(n / i); &#125; else &#123; seq2.emplace_back(i); seq2.emplace_back(n / i); &#125; &#125;&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; T; while (T--) &#123; vector&lt;int&gt;().swap(seq1); vector&lt;int&gt;().swap(seq2); vector&lt;pair&lt;int, int&gt;&gt;().swap(ans); cin &gt;&gt; a &gt;&gt; b; factor(a); factor(b, 0); sort(seq1.begin(), seq1.end()); seq1.erase(unique(seq1.begin(), seq1.end()), seq1.end()); sort(seq2.begin(), seq2.end()); seq2.erase(unique(seq2.begin(), seq2.end()), seq2.end()); for (int i = 0; i &lt; (signed)seq1.size(); ++i) for (int j = 0; j &lt; (signed)seq2.size(); ++j) &#123; if (seq1[i] &lt; seq2[j]) ans.emplace_back(seq1[i], seq2[j]); else ans.emplace_back(seq2[j], seq1[i]); &#125; sort(ans.begin(), ans.end()); ans.erase(unique(ans.begin(), ans.end()), ans.end()); cout &lt;&lt; ans.size() &lt;&lt; endl; &#125;&#125; B-路径数量(矩阵快速幂) 题目描述给出一个 n * n 的邻接矩阵A.A是一个01矩阵 .A[i][j] = 1表示i号点和j号点之间有长度为1的边直接相连.求出从 1 号点 到 n 号点长度为k的路径的数目. 输入描述:第1行两个数n,k (20 ≤n ≤ 30,1 ≤ k ≤ 10)第2行至第n+1行，为一个邻接矩阵 输出描述:题目中所求的数目 示例1输入4 20 1 1 01 0 0 11 0 0 10 1 1 0 输出2 说明 样例如图:第一条路径：1-2-4第二条路径：1-3-4 矩阵\(A^n[i][j]\)表示从i到j距离为n的路径数量。题目求长度为k的路径数量即\(A^k[1][n]\) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN = (int)1e2 + 5;struct Mat&#123; ll n, m[MAXN][MAXN]; Mat() &#123; n = 0; memset(m, 0, sizeof(m)); &#125;&#125;;Mat mul(Mat m1, Mat m2)&#123; Mat ret; ret.n = m1.n; for (int i = 1; i &lt;= ret.n; ++i) for (int j = 1; j &lt;= ret.n; ++j) for (int k = 1; k &lt;= ret.n; ++k) if (m1.m[i][k] &amp;&amp; m2.m[k][j]) ret.m[i][j] += (m1.m[i][k] * m2.m[k][j]); return ret;&#125;Mat quickmul(Mat m, ll n)&#123; Mat ret; ret.n = m.n; for (int i = 1; i &lt;= n; ++i) ret.m[i][i] = 1; while (n) &#123; if (n &amp; 1) ret = mul(ret, m); m = mul(m, m); n &gt;&gt;= 1; &#125; return ret;&#125;int n, k;Mat a;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; n &gt;&gt; k; a.n = n; for (int i = 1; i &lt;= a.n; ++i) for (int j = 1; j &lt;= a.n; ++j) cin &gt;&gt; a.m[i][j]; a = quickmul(a, k); cout &lt;&lt; a.m[1][n] &lt;&lt; endl;&#125; C-数列下标(暴力) 题目描述给出一个数列 A，求出一个数列B.其中Bi表示 数列A中Ai右边第一个比Ai大的数的下标(从1开始计数),没有找到这一个下标Bi就为0,输出数列B 输入描述:第一行1个数字 n (n ≤ 10000)第二行n个数字第 i 个数字为 Ai (0 ≤ Ai ≤ 1000000000) 输出描述:一共一行，第 i 个数和第 i+1 个数中间用空格隔开. 示例1输入63 2 6 1 1 2 输出3 3 0 6 6 0 说明样例不用解释 暴力即可，但是比赛这题数据有点问题，1e4是过不了的，换成1e5就过了，QAQ 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN = (int)1e5 + 5;int n, a[MAXN], ans[MAXN];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i]; for (int i = 1; i &lt; n; ++i) &#123; int idx = 0; for (int j = i + 1; j &lt;= n; ++j) if (a[i] &lt; a[j]) &#123; idx = j; break; &#125; ans[i] = idx; &#125; ans[n] = 0; for (int i = 1; i &lt;= n; ++i) cout &lt;&lt; ans[i] &lt;&lt; ' '; cout &lt;&lt; endl;&#125; D-星光晚餐(找规律) 题目描述Johnson先将天上n个星星排成一排，起初它们都是暗的。 他告诉他的妹子，他将挥动n次魔法棒，第i次挥动会将编号为i的正整数倍的星星的亮暗反转，即亮的星星转暗，暗的星星转亮。 Johnson想问Nancy，最终会有多少个星星依旧闪亮在天空。 输入描述:一个整数n，含义请见题目描述。 输出描述:一个整数ans，即n次操作后会有多少个星星依旧闪亮。 示例1输入3 输出1 示例2输入7 输出2 备注对于60%的数据：n ≤ \(2×10^6\)对于100%的数据：n ≤ \(10^{18}\) 打表找了一下规律发现正好符合sqrt(n)向下取整。 12345678910#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll n;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; n; cout &lt;&lt; (ll)floor(sqrt(n)) &lt;&lt; endl;&#125; E- 括号序列(模拟) 题目描述给定括号长度N，给出一串括号（只包含小括号），计算出最少的交换（两两交换）次数，使整个括号序列匹配。我们认为一个括号匹配，即对任意一个’)’，在其左侧都有一个’(‘与它匹配，且他们形成一一映射关系。 输入描述:第一行：整数N，表示括号序列长度第二行：一个字符串，表示括号 输出描述:一个整数，表示最少的交换次数 示例1输入6(()))( 输出1 示例2输入6)))((( 输出2 说明对于80%的数据：n ≤ 3000对于100%的数据，n ≤ \(5×10^{6}\) 括号字符串中已经匹配的括号不需要交换，那么只需要统计一下未匹配的括号的数量，交换一次可以消去4个括号。 1234567891011121314151617#include&lt;bits/stdc++.h&gt;using namespace std;int n, l = 0, r = 0;string s;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; n &gt;&gt; s; for (int i = 0; i &lt; (signed)s.size(); ++i) &#123; if (s[i] == '(') l++; if (s[i] == ')'&amp;&amp;l &gt; r) r++; &#125; cout &lt;&lt; ceil((double)(n - r * 2) / 4) &lt;&lt; endl;&#125; F- 括号序列(打表) 题目描述输入一个整数X，求一个整数N，使得\(N!\)恰好大于\(X^X\)。 输入描述:第一行：一个整数X 输出描述:第一行：一个整数N 示例1输入7 输出10 备注每个测试点所对应的X满足：第i个测试点输入的值为第i-1个测试点输入的值乘以10再加上7。特别的，第一个测试点所输入的值为7。提示：数据共有10组。 数据较大时肯定不能通过直接比较的方法来计算了，计算位数是一个不错的方法，分别计算\(N!\)的每一个数字，\(N!=\prod_{i=1}^{N}lgi\)，\(X\)的位数为\(lgX\)，\(X^X\)的位数为\(lgX^X\)，化简之后为\(XlgX\)。由于备注已经说明测试数据了，打个表结果就出来了，就是算到最后两个时间可能会稍微长一点… 我的代码:1234567891011#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;string X;ll a[10] = &#123; 10,94,892,8640,84657,834966,8267019,82052137,815725636,8118965902 &#125;;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; X; cout &lt;&lt; a[X.size() - 1] &lt;&lt; endl;&#125; 利用Stirling公式 \(n!\approx\sqrt{2\pi n}(\frac{n}{e})^n\):1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef long double lb;using namespace std;lb N, X;ll l = 1, r = (ll)1e18, ans;bool check(lb N)&#123; N = log(2 * acos(-1) * N) / 2 + N * log(N / exp(1)); if (N &gt; X) return true; return false;&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; X; X *= log(X); while (l &lt;= r) &#123; ll mid = (l + r) &gt;&gt; 1; if (check((lb)mid)) &#123; ans = mid; r = mid - 1; &#125; else l = mid + 1; &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>newcoder</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>CONTEST</tag>
        <tag>ALL KILLED</tag>
        <tag>gcd</tag>
        <tag>矩阵快速幂</tag>
        <tag>模拟</tag>
        <tag>打表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 1028 Ignatius and the Princess III(DP入门)]]></title>
    <url>%2Fpost%2F511e6933.html</url>
    <content type="text"><![CDATA[HDU1028 Problem Description“Well, it seems the first problem is too easy. I will let you know how foolish you are later.” feng5166 says.“The second problem is, given an positive integer N, we define an equation like this: N=a[1]+a[2]+a[3]+…+a[m]; a[i]&gt;0,1&lt;=m&lt;=N;My question is how many different equations you can find for a given N.For example, assume N is 4, we can find: 4 = 4; 4 = 3 + 1; 4 = 2 + 2; 4 = 2 + 1 + 1; 4 = 1 + 1 + 1 + 1;so the result is 5 when N is 4. Note that “4 = 3 + 1” and “4 = 1 + 3” is the same in this problem. Now, you do it!” InputThe input contains several test cases. Each test case contains a positive integer N(1&lt;=N&lt;=120) which is mentioned above. The input is terminated by the end of file. OutputFor each test case, you have to output a line contains an integer P which indicate the different equations you have found. Sample Input41020 Sample Output542627 大致题意，一个数n可以拆分为[1, m]个大于0的整数相加，输入整数n，输出有多少种相加的方法，其实就是整数划分。 参考了这篇博客 https://blog.csdn.net/l2533636371/article/details/78077640想了很久，规律也找出来了，但是没能总结出状态转移方程，代码很精巧，值得学习。 123456789101112131415#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN = (int)1e3 + 5;int N, dp[MAXN];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); memset(dp, 0, sizeof(dp)); dp[0] = 1; for (int i = 1; i &lt;= 120; ++i) for (int j = 0; i + j &lt;= 120; ++j) dp[i + j] += dp[j]; while (cin &gt;&gt; N) cout &lt;&lt; dp[N] &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>HDU</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>DP</tag>
      </tags>
  </entry>
</search>
